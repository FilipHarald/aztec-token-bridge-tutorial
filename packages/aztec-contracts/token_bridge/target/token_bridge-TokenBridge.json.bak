{"noir_version":"0.33.0+2d702155f9341cac08a960f271e3ed5450740729","name":"TokenBridge","functions":[{"name":"exit_to_l1_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+1dBXhURxfdZDdBgkPwtgGK2050A6VAcahAqbe0jQItUiBQh7o7dff+dXd3d3d3hypt6X+G7JCbxyTZt3snvNv2fd/5Mjt5c/fcuXPv6HubFqq++jcJhXbLqE6nAeH433Qgx5Nn/tJ0xJKXaSnbwpLXypLXxpLXzpLXCRjlydvIcl+OJa+HJa+nJa9PPI9eafG/o+J/86KF+fkVRbkVKk+VRHOLS2MF0fyC0sKYiqmCWEF5biwvryKWHysqLi0uihar/LwKVVlQnFcZrb5uSq+RFU3pyi1zyfPmpHkq5c0x9osQrroeVsfTfUM16X4kfXP8HlPuFny+FbgNuD29Jt9cYU8dRFO7VH9GWbek89nmDrY2FI26rL8BjLJuZay/O4XU30BGWbcx1t9djPVniw13kNhwJ0nfRdK3e2LD3fh8D3AvcF96TT/llX03kXEPSd9L0vd5ZN+Pzw8ADwIP1SP7fiLjAZJ+kKQf8sh+GJ8fAR4FHqtH9sNExiMk/ShJP+aR/Tg+PwE8CTxVj+zHiYwnSPpJkn7KI/tpfH4GeBZ4zhKLufuj5x23OdofPU3Sz6fX3R+9gM8vAi8BL9dTvy8QGS+S9Esk/bJH9iv4/CrwGvB6PbJfITJeJenXSPp1j+w38PlN4C3g7Xpkv0FkvEnSb5H02x7Z7+Dzu8B7wPv1yH6HyHiXpN8j6fc9sj/A5w+Bj4CP65H9AZHxIUl/RNIfe2R/gs+fAp8Bn1vac3r876j432hql+oT4vONL/h8Q9HxsJab47gevmDsl750VA9fxush3VMXacx10Y9PVjQnLucrkP4a+Ab4FvgO+B74AfgRWAGsBH4CfgZ+AX4FfgN+B1YBfwB/An9pnwH+Tq+unDQgHQgDESADyASaAE2BZvEKpHWp+TQN1c772pL3jSXvW0ved5a87y15P1jyfrTkrbDkrbTk/WTJ+9mS94sl71dL3m+WvN8teasseX9Y8v605P1lyVttyfvbkqcT3rw0S166JS9syYtY8jIseZmWvCaWvKaWvGbxPHqZuD4q/jea2lXLZ1ONX18xxMKKSn1F1deMcfX0DDfzJa8tUtFZ2+Iblvqrtuu3qcvKjdef+o7RFmcE2Rb5a3mq71PTOUp0Vj+kIiu3Vv2pHxltcWYwbRH18FQrktS5sHIdndXK5GTFLPWnfmK0xVlBs0XMylP97F/nojp0Vr/4lVVUZ/2pXxltcXZwbJFbD0/1mx+di+rVWf2euKyyBupPrWK0xTlBsEVRgzzVH4npHE1AZ/VnIrKiCdWf+ovRFueuX1sUJMhTrW5I5/yEdVZ/1ysrv9JH/Sk9sOeyxXnryxZFvniqtLp1jvnUWaXXIau40nf9qTCjLc5vfFtEk+CpIjado0nprDLWlaWSrD+VyWiLCxrTFuVJ81RNauucl4LOqimRlVuZUv2pZoy2uLCRbBFN7VKM6wOKcX6r6PwsVVtcJMQWjPMgxTiOV+cw2uJiIbZgHO8pxvGKOp/RFpcIsQVjv6YY47K6iNEWlzqyBfe5Fkb/VYztT3HWX3qo9sW9V8h4Nm3tXmFzGDoLaAG0BFoBrYE2QFugHdAe6ABkAx2BTkBnoAvQFegGdAc2ADYENgJygB5AT6AXsDHQG+gD9AX6Af0te4XNLXs6WZa8Fpa8lpa8Vpa81pa8Npa8tpa8dpa89pa8Dpa8bEteR0teJ0teZ0teF0teV0teN0ted0veBpa8DS15G1nycix5PSx5PS15vSx5G1vyelvy+ljy+lry+lny+ofd7xVSn0011jdnmGeYvcIsxjnLLUL2Cluw1F+1XVumLmvtXmErRlvcKmSvsHVqOtfaK2yTiizPXmFbRlvcJmSvsF2SOtv2CtsnJ8u6V9iB0Ra3C9krzPavc517hR39yqpnr7AToy3uELJX2NmPzg3sFXZJXFaDe4VdGW1xp5C9wm6J6ZzQXmH3RGQluFe4AaMt7hKyV7hhQzr72CvcKMy3V5jDaIu7hewV9gjz7RX2DPPtFfZitMU9QvYKNw7z7RX2DvPtFfZhtMW9QvYK+4b59gr7hfn2Cvsz2uI+IevwjOsDinF+q25jXIe/X4gtGOdBinEcr+5ktMUDQmzBON5TjOMVdQ+jLR4UYgvGfk0xxmV1P6MtHhKyV8jov4qx/amHBO0VMr6HYe1e4QAYeiAwCBgMDAGGAlFAAblAHpAPFACFQBEQA4qBYcBwYBNgBLApMFKPh4DRwGbAGGAsMA4YD0wAJgKT4ps2dP9mgGVPZ6Alb5Alb7Alb4glb6glL2rJU5a8XEteniUv35JXYMkrtOQVWfJilrxiS94wS95wS94mlrwRlrxNLXkjLXmjLHmjLXmbWfLGWPLGWvLGWfLGW/ImWPImWvImhd3vFVKfTTXWD2DZ66reKxzIOGd5Sche4SCW+qu26+DUZa3dKxzCaIuXhewVDk1N51p7hdFUZHn2ChWjLV4RsleYm6TOtr3CvORkWfcK8xlt8aqQvcIC/zrXuVdY6FdWPXuFRYy2eE3IXmHMj84N7BUWJy6rwb3CYYy2eF3IXuHwxHROaK9wk0RkJbhXOILRFm8I2SvctCGdfewVjgzz7RWOYrTFm0L2CkeH+fYKNwvz7RWOYbTFW0L2CseG+fYKx4X59grHM9ribSF7hRPCfHuFE8N8e4WTGG3xjpB1eMb1AcU4v1WvMK7DvyvEFozzIMU4jlevM9riPSG2YBzvKcbxinqL0RbvC7EFY7+mGOOyepfRFh8I2Stk9F/F2P6Uq/rz7hOmaufJYS6ehcUueU5h45mX65Ln5mw8Y+UueW7BxrOiTHPTMbaccJ1M9tCmkPTmJL0FSTcjafpeT/reT/peUPre0FrvFSVp+l5S+t5S+l5T+t5T+l5U+t5U+l5V+t5V+l5W+t5W+l5X+t5X+l5Y+t5Y+l5Z+t5Z+l5a+t5a+l5b+t5b+l5c+t5c+l5d+t5d+l7e/qRO6LOS9FlK+qwlfRaTPqtJn+Wkz3rSZ0Hps6L0WVL6rCl9FpU+q0qfZaXPutJnYemzsvRZWvqsLX0Wlz6rS5/lpc/60meB6bPC9Fli+qwxfRaZPqtMn2WmzzpPImm6/0z3p+n+Nd3fpvvfdH+c7p/T/XW6/0735+n+Pd3fp/v/9HwAPT9AzxfQ8wf0fAI9v0DPN9DzD/R8BD0/Qc9X0PMX9HwGPb9Bz3fQ8x/0fIg5P7Il/m4FTAWmAVsD04FtgG2B7YDtgR2AHYGdgJ2BXYAZwK7AbsDuQAlQCpQB5UAFUAnMBGYBs4E9gD2BOcBcMyCKX9xxfh5bnFdFLnnOZ+MZddq/75U8zzxvxpr4FKr9OwbaXub3Ctb0SfG/80n+XuHav2OwAJ8XAouAqnB1vv65L92200PrXt46iaZ2qeyQm7FuiIfn2t+monWxOO53S8Kh2gd99D/e8+Tpm3I8pMIOKzHVQyKLw3wNfknYjXHTmeuPU+e9LbJKo2XlBaq0sBxr6yUFsbKy4jylcksKSwpLc2OVFaUFKlYQg8yyktwYvi63pExVREsKK7QjNgvVOB29uB1xb0ZbUb77hB0S1sK55e7L2Bhc6b0v6fmZ5Fq5cgQAzZXLYY1cThvtx9zwTeDXcnuEqntTfTVGb+oq4HLzXMDIM5Pw3D/uFwfE/x4Y/7s0/ndZPF70i99/ED4fDBwCHAocBhwOHAEcCRwFHA0cAxwLHAccD5wAnAicBJwMnAIsB04FTgNOB84AzgTOAs4GzgHOBc4DzgcuAC4ELgIuBi4BLgUuAy4HrvCOLpYlMJJI1RkYDaMOYHTS/zE2mMbsVTl5U75Xhh0SvtJBr3pVwHtVrfdVDnrVjDjXxoj+nFHVJc8DHDnF1aTdsg9lrmKMjDSqG9IZ8UbSGFGJ0wC0YV8Td6BrtU4uDHC1g8h0NbPXuNI73aHeqXK8znEdRlO7lG6Y14X5bXO9o7mDlntQXC53XVzrqC5ucFQXNzisiwMc1cUPGcGOKa784cf1q3eDTzS4avsrhJx4YWyXitHWirP+MuL1Zhtxh3zWZ0Pticp00Wdx1QkdVN5Y3yg5mtqlrnPUCVDSPjmrhr5Hc77RQVD4JSBHEv0M3lLV+aZwMAMMpy1ou7yJDE6StU9Ddc5pn5uJLJWXB9/AnlRleWVeQVFxbqkqzCssrMyvLCqM5ZdXFuSXlBdVqPySvNziiqJopYpVVBQV5JUVFVYWl5cVVtKgrcrz8vLLi0vLVEFuYUlpNFaeVxKtzC/Ky42WlOcVlZfnxQoLS/LyygtjlbHiWG5uSWVeLFpQVFQcLczNK851ZZ+b4/ZpzNk15zIM7cRuiY8GbpUSwF3xu8VBsL7NUcd1m8PZi66LWx3Uxe2O6uJ2h3WxwNHI/reAz+Rc+cPvAZ/JuWr7q4TM5BjbpWK0tVr130zOe6lbHM3k7pA4k7vD8UzuDgdBYfW/cCZ3ZziYAWa1o5nCncJmcncxzuRWMc7kXNnnLjKTq6tTCPISnEuerjqYuyV2MHc77mDudtDBhDIbp4Ph3OcN0F5RrQ4mVV5pjmzBfVTvHsYOmrH9Kc76o359TwIddMq/UBHm6whrLY8GqIMOObLPvf+gpdb74s56v+0gUzS1S9V1oIfzhFqqsq7mDC4ODG/qkDuouqrDlH+WIuD20A7zgIOB0YOOBokPOlyKvt9RXTzkqC4ecrws76IuIsyDNG5+rvwhY/3q3eCyvKu2n9lIg/JoapdibJeK0daKs/7+Kcvy9zlaNXnY5arJA446gYcdrppozg87CArNG2nVpKGyfgZvqer8SDiYAaa5o1nlI42wLM9pn0cZl+Vp0E511u/KPo+uh1m/q8eXHouPBh6XEsBd8XvMQbB+wlHH9YTD2Yuui8cd1MWTjuriybDbR2VcjOxbBHwm58ofWgZ8Jueq7bcSMpNjbJeK0daq1X8zOe+lHnM0k3tK4kzuKcczuaccBIV2/8KZ3NPhYAaYdo5mCk8Lm8k9wziTa8U4k3Nln2fWwwErziU4lzxddTDPSuxgnnXcwTzroIPpIOSAFWcAy3A0gk2VV7aQA1bPMXbQjO1PZTvqAJ5rhANWzzMesKq1PBqgDrqDI/s8b7EP96x3AWP8Wcoo6wXGvqwx3//3gqOBw4thh4RfDPPLfYmxMbjS+6VwTQUzyW3U9/8tFTKaXuDIKV6ubzSdaqN7iXE0QKO6If1PODb7StyBXrUdm+UwwMsOItPLjjfkuPROd6h3yr+0HvBNTd0wX3MwrXzd0RT7dYcbea86qos3HNXFG46Pp7qoi84B39R05Q9dAr6p6artdxWyqcnYLhWjrVXX/zY1vdeaPourTuig8k2Xa86vOeoE3nS45qw5v+kgKGwoZFPzNcaB4FvhYAaYDR2tyb3VCJuanPZ5m3FTsyvjmqkr+7y9Ho6nci7D0E7snfho4F0pAdwVv3ccBOv3HHVc7zmcvei6eNdBXbzvqC7ed1gXSx2N7HMCPpNz5Q89Aj6Tc9X2ewqZyTG2S8Voa9Xzv5mc91LvOJrJfSBxJveB45ncBw6CQp9/4Uzuw3AwA0wfRzOFD4XN5D5inMn1ZJzJubLPR+vheCrnEpxLnq46mI8ldjAfO+5gPnbQwfQTcjyVM4B1cTSCTZVXfyHHUz9h7KAZ25/q76gD+KQRjqd+yng8tWtmMDvofo7s8+k/aKn1s7izfm47yBRN7VJ1HejhPKGWqizGQ1FO3jdn6pA7qLqqw1RlfRFwe2iH+cLBwOhLR4PELx0uRX/uqC6+clQXXzlelndRF4MCvizvyh8GB3xZ3lXbHyJkWZ6xXSpGW6sh/y3Le681fRZXndDB7tcuV02+cNQJfO1w1URz/tpBUMgVsiz/BeNA8JtwMANMrqNZ5TeNsCzPaZ9vGZflhzDO+l3Z59v1MOt39fjSd/HRwPdSArgrft85CNY/OOq4fnA4e9F18b2DuvjRUV38GHb7qIyLkX1+wGdyrvyhIOAzOVdtv1DITI6xXSpGW6vC/2Zy3kt952gmt0LiTG6F45ncCgdBYdi/cCa3MhzMADPM0UxhpbCZ3E+MM7lCxpmcK/v8tB4OWHEuwbnk6aqD+VliB/Oz4w7mZwcdzCZCDlhxBrDBjkawqfIaIeSA1S+MHTRj+1MjHHUAvzTCAatfGQ9YDckMZge9iSP7/Eo66MZ6f90yRx3fb2GHhH8L88v9nTEwu9L793BNBTPJbdSXJS511NhWhR0SXuWgsf0R8Mam9f7DQWOzceU40fdFmP/1aZwjtT8Dvif0e9ze3Lb5KxzstqN/DfoBB22H8y3fqwNeh7pt/xXmX59n9Bn1F6M9/g64PXR7+duBL+upApc9XOit9y81R265ozKDHbsPcKT3aEezeO5Yy2gfNZp5762xBtYHOBpYp0UcEk6L8MtNjwR7YK31To/UVDCT3EZtbAc6amzhiEPCYQeNLRLwxqb1jjhobC64aqeIOOjFMiLB1lvPujIc6J0ZcdN7c/NskjzPfG+G5tYpVLOmrT/rgLs6nj6QpJeRtOawmpRrikQzoDmQFanJNxf3TIdxWUw1ZYxJLSK8gd5rmxaRGhs0I+nmJJ3lsU1LJFoBrYE2kdryONulXhHJdOCXbRlnUWYkHaqjDqKpXWp/xo6+X1xOO+jfHugAZAMdgU5AZ6AL0BXoBnQHNgA2BDYCcoAeQE+gF7Ax0BvoA/QF+gH9gQHAQGAQMBgYAgwFooACcoE8IB8oAAqBIiAGFEdqjribPZl28TZA89pb8jpY8rIteR0teZ0seZ0teV0seV0ted0sed0teRtY8ja05G1kycux5PWw5PW05PWy5G1syettyetjyetryetnyetvyRtgyRtoyRtkyRtsyRtiyRtqyYta8pQlL9eSl2fJy7fkFVjyCi15RZa8mCWvmMRDc3n3j6OpXbViTso/OszQF1ZUVl/tGfvVsQE/qxLXubwDX/0VZ/PJUh0ZbTFOhC0qVCe2+itTndlkxVQXRluMF2GLqOrKVX8VUdWNS1ZZVHVntMUECbaIRdUGXPWnf0OASVYFZG3EaIuJAmxRpl9ZzFR/Mf3CNyZZUf3KYkZbTAq+LSq0zr146q9My9qYR1ZMy+rNaIvJwbeFFq36sNRfxRpZfVlkla2R1Y/RFlMCb4vYGp37s9TfGppqAIesimpZAxltsXnQbVFWrfMgjvqLVcsazCGrWmU1hNEWWwTcFuVxnYcy6FwalxVlkFUUl6UYbbFlsG2Ra56kzU1dZ2Vk5aUsK1ZpZOUz2mKrQNsiVmp0Lki9/tY+IV2YsqyitbKKGG0xNdC2KFircyxlndVaWcURvjXLsYzPTk0LyIPSDVyKcd1MMa77qAmMtthaiC0Y1wcU4/xWTWa0xXQhtmCcBynGcbzagtEW2wixBeN4TzGOV9RURltsK8QWjP2aYozLajqjLbYT8uYjRv9VjO1Puaq/dE/9BWFfee2LcRjHoVoG9xkgfd6qbYT/HNTwCK+tufU+KFxz9odT7z0C/jSJbo/DHei9p5B3QmzC6I+MtlZ7BrzdaH8Z5qDdzAu43u0c+ct8If4ygtFfGG2tXNUft503Tb7+cr0Za86ShmqfidbxzJylHkHSz6fXpDeN1D5jPVJzAkYDm0XqPmMdTe1SB4drztJy1unCgL9xVus80oHei4TMBUcyjp/HMMYfxnajpNjiYMbztmMjbnw4SH5hi7FjSFwdm2CMHYfEeGACMNFhjD0kXPNsApWbap0uCXiM1TqPc6D33lL2ZzjPvDHGWMZ2o6TY4hDGGDs54saHg+QXthg7icTVyQnG2ClIbA5sAWzpMMYeGq551ovKTbVO9wt4jNU6T3Gg9/5S9vo4z8MwxljGdqOk2OJQxhg7NeLGh4PkF7YYuxWJq1MTjLHTkNgamA5s4zDGHhaueXaWyk21TpcGPMZqnac50HuZlH1jRl/cljHGMrYbJcUWhzHG2O0ibnw4SH5hi7Hbkri6XYIxdnskdgB2BHZyGGMPD9e8i4DKTbVODwl4jNU6b+9A70OF+PX2jL64M2OMZWw3SootDmeMsbtE3PhwkPzCFmN3JnF1lwRj7AwkdgV2A3Z3GGOPCNe824XKTbVOjwh4jNU6z3Cg95FC/HoGoy+WMMZYxnajpNjiCMYYWxpx48NB8gtbjC0hcbU0wRhbhkQ5UAFUOoyxR4Zr3pVF5aZap8cEPMZqncsc6H2sEL8uY/TFmYwxlrHdKCm2OJIxxs6KuPHhIPmFLcbOJHF1VoIxdjYSewB7AnMcxtijwjXvHqRyU63TEwIeY7XOsx3ofaIQv57N6ItzGWMsY7tRUmxxFGOMnRdx48NB8gtbjJ1L4uq8BGPsfCT2AhYACx3G2KPDNe9ypXJTrdNTAh5jtc7zHei9XIhfz2f0xUWMMZax3SgptjiaMcZWRdz4cJD8whZjF5G4WpVgjF2MxBJgb2AfhzH2mHDNu7Gp3FTr9PSAx1it82IHep8hxK8XM/rivowxlrHdKCm2OIYxxu4XcePDQfILW4zdl8TV/RKMsfsjcQBwILDUYYw9NlzzWwNUbqp1enbAY6zWeX8Hep8jxK/3Z/TFZYwxlrHdKCm2OJYxxh4UcePDQfILW4xdRuLqQQnG2IOROAQ4FDjMYYw9Llzz2y1Ubqp1en7AY6zW+WAHel8g5flNRl88nDHGMrYbJcUWxzHG2CMibnw4SH5hi7GHk7h6RIIx9kgkjgKOBo5xGGOPD9f8FhaVm2qdXhzwGKt1PtKB3pdI2ctm9MVjGWMsY7tRUmxxPGOMPS7ixoeD5Be2GHssiavHJRhjj0fiBOBE4CSHMfYE2DfHQay5POAxVut8vAO9r5Di14y+eDJjjGVsN0qKLU5gjLGnRNz4cJD8whZjTyZx9ZQEY+xyJE4FTgNOdxhjTwzX/FYrlZtqnV4V8BirdV7uQO+rhfj1ckZfPIMxxjK2GyXFFicyxtgzI258OEh+YYuxZ5C4emaCMfYsJM4GzgHOdRhjTwrX/PY1lZtqnV4X8BirdT7Lgd7XC/Hrsxh98TzGGMvYbpQUW5zEGGPPj7jx4SD5hS3Gnkfi6vkJxtgLkLgQuAi42GGMPRn27eUg1twU8Birdb7Agd43C/HrCxh98RLGGMvYbpQUW5zMGGMvjbjx4SD5hS3GXkLi6qUJxtjLkLgcuAL4n8MYewrsu7GDWHNbwGOs1vkyB3rfLsSvL2P0xSsZYyxju1FSbHEKY4y9KuLGh4PkF7YYeyWJq1clGGOvRuIa4FrgOocxdjns29tBrLkr4DFW63y1A73vFuLXVzP64vWMMZax3SgptljOGGNviLjx4SD5hS3GXk/i6g0JxtgbkbgJuBm4xWGMPRX27eMg1twX8Birdb7Rgd73C/HrGxl98VbGGMvYbpQUW5zKGGNvi7jx4SD5hS3G3kri6m0JxtjbkbgDuBO4y2GMPQ327esg1jwU8Birdb7dgd4PC/Hr2xl98W7GGMvYbpQUW5zGGGPvibjx4SD5hS3G3k3i6j0Jxth7kbgPuB94wGGMPR327ecg1jwW8Birdb7Xgd6PC/Hrexl98UHGGMvYbpQUW5zOGGMfirjx4SD5hS3GPkji6kMJxtiHkXgEeBR4zGGMPQP27e8g1jwV8BirdX7Ygd5PC/Hrhxl98XHGGMvYbpQUW5zBGGOfiLjx4SD5hS3GPk7i6hMJxtgnkXgKeBp4xmGMPRP2HeAg1jwX8BirdX7Sgd7PC/HrJxl98VnGGMvYbpQUW5zJGGOfi7jx4SD5hS3GPkvi6nMJxtjnkXgBeBF4yWGMPQv2Hegg1rwU8BirdX7egd4vC/Hr5xl98WXGGMvYbpQUW5zFGGNfibjx4SD5hS3Gvkzi6isJxthXkXgNeB14w2GMPRv2HeQg1rwW8BirdX7Vgd6vC/HrVxl98U3GGMvYbpQUW5zNGGPfirjx4SD5hS3Gvkni6lsJxti3kXgHeBd4z2GMPQf2Hewg1rwV8BirdX7bgd5vC/Hrtxl98X3GGMvYbpQUW5zDGGM/iLjx4SD5hS3Gvk/i6gcJxtgPkfgI+Bj4xGGMPRf2HeIg1rwX8Birdf7Qgd7vC/HrDxl98VPGGMvYbpQUW5zLGGM/i7jx4SD5hS3Gfkri6mcJxtjPkfgC+BL4ymGMPQ/2Heog1nwU8Birdf7cgd4fC/Hrzxl98WvGGMvYbpQUW5zHGGO/ibjx4SD5hS3Gfk3i6jcJxthvkfgO+B74wWGMPR/2jTqINZ8FPMZqnb91oPfnQvz6W0Zf/JExxjK2GyXFFuczxtgVETc+HCS/sMXYH0lcXZFgjF2JxE/Az8AvDmPsBbCvchBrvgp4jNU6r3Sg99dC/Holoy/+yhhjGduNkmKLCxhj7G8RNz4cJL+wxdhfSVz9LcEY+zsSq4A/gD8dxtgLYd9cB7Hmu4DHWK3z7w70/l6IX//O6It/McZYxnajpNjiQsYYuzrixoeD5Be2GPsXiaurE4yxf+tEBv4HpGe4i7EXwb55DmLNioDHWK3z3w70XinEr/9m9MVwBh8vxnajpNjiIsYYG8lw48NB8gtbjNVt0MTSSEZiMTYD92UCTYCmDmPsxbBvvoNY80vAY6zWWdcxt9xfhfh1BqMvNmOMsYztRkmxxcWMMbZ5hhsfDpJf2GJsMxJXmycYY7NwXwugJdDKYYy9BPYtcBBjVwU8xmqdsxzE2D+E+HUWoy+2ZoyxjO1GSbHFJYwxtk2GGx8Okl/YYmxrElfbJBhj2+K+dkB7oIPDGHsp7FvoIMauDniM1Tq3dRBj/xbi120ZfTGbMcYythslxRaXMsbYjhlufDhIfmGLsdkkrnZMMMZ2wn2dgS5AV4cx9jLYt8hBjE1vEuwYq3Xu5CDGhpvI8OtOjL7YjTHGMrYbJcUWlzHG2O4Zbnw4SH5hi7HdSFztnmCM3QD3bQhsBOQ4jLGXw74xBzE2M+AxVuu8gYMY20SIX2/A6Is9GGMsY7tRUmxxOWOM7ZnhxoeD5Be2GNuDxNWeCcbYXrhvY6A30MdhjL0C9i12EGObBzzGap17OYixWUL8uhejL/ZljLGM7UZJscUVjDG2X4YbHw6SX9hibF8SV/slGGP7474BwEBgEImx5kpntnPbEF999s9wG1+jqV3qwHB1RbO/ZyaDtx2F47pruRc6tv+X6Xz1MIQx5tJ60HJz4mmvj91EfKlvyO5jN6fX9rGhkBcFFJAb9zGb7KHEZ6MkrUg6N6O27Dx8zgcKgMJ6ZOcRGfkkXUDShR7ZRfgcA4qBYfXILiIyYiRdTNLDPLKH4/MmwAhg03pkDycyNiHpESS9qUf2SN0ugNHAZvXIHklkjCLp0SS9mUf2GHweC4wDxtcjm7aTMRmJtZMJuG8iMAmYXI/sCUTeRJKeRNKTPbyn4PPmwBbAlvXInkJkbE7SW5D0lh7ZW+HzVGAasHU9srciMqaS9DSS3tojezo+bwNsC2xXj+zpRMY2JL0tSW/nkb09Pu8A7AjsVI/s7YmMHUh6R5LeySN7Z3zeBZgB7BqXnRH/v4mptmtU/G80tWtNPEvzyObu3/qGePshc+2W4SHO3QntzDhA3C3DzQCbW+chjDrv7qjj3T3e8WbEkRla9+JuxGkhN/YLMfHMKyotUpWxcpd1sLOjNszNc4gQnpFQsNvUOrIbGsHoy6T7h+oewZTAQKVAGVBumU2GmSt6IKOsEsYAWcE8Q/PapoKMPEpJuoykyz0jkkp8ngnMAmbXM9qpJDJmkvQskp7tkb0HPu8JzAHm1iN7DyJjT5KeQ9JzPbLn4fN8YC9gQT2y5xEZ80l6L5Je4JG9EJ8XAVXA4npkLyQyFpF0FUkv9shegs97A/sA+yY4U1iS4ExhP9y3P3AAcGA9svcj8vYn6QNI+kAP76X4vAw4CDi4HtlLiYxlJH0QSR/skX0IPh8KHAYcXo/sQ4iMQ0n6MJI+3CP7CHw+EjgKOLoe2UcQGUeS9FEkfbRH9jH4fCxwHHB8PbKPITKOJenjSPp4j+wT8PlE4CTgZDJT0IOfRpgp5JkBGL24O0RGWVFXHPsL4MjY39WacZ3iesZ1AmPnegpj56r1xqp8o8w0OKfLFropyy7PrywrKy6scFkHJwgZwe8uhKeUmQbtyJbHg82pGfEKMdP/5fHpP724A9FyxkB0mqNlkNMs9cDdcE5tpGWrVOuYU+dBIRk6My5JqcFCdE5n1HmIEJ3DjDoPFaIzY4eloo2kczS1SynG+vskXcbAJDckg2eeEJ75QngWCOFZKIRnkRCeMSE8i4XwHCaE53AhPDcRwnOEEJ6bCuE5UgjPUUJ4jhbCczMhPMcI4TlWCM9xQniOF8JzghCeE4XwnCSE52QhPKcI4bm5EJ5bCOG5pRCeWwnhOVUIz2lCeG4thOd0ITy3EcJzWyE8t3PEM8h7ods3ks7R1C61A2P9fSFkv2jHkAyeOwnhubMQnrsI4TlDCM9dhfDcTQjP3YXwLBHCs1QIzzIhPMuF8KwQwrNSCM+ZQnjOEsJzthCeewjhuacQnnOE8JwrhOc8ITznC+G5lxCeC4TwXCiE5yIhPKuE8FwshOcSITz3FsJzHyE89xXCcz8hPPcXwvMAITwPFMJzqRCey4TwPEgIz4OF8DxECM9DhfA8TAjPw4XwPEIIzyOF8DxKCM+jhfA8RgjPY4XwPE4Iz+OF8DxBCM8ThfA8SQjPk4XwPEUIz+VCeJ4qhOdpQnieLoTnGUJ4nimE51lCeJ4thOc5QnieK4TneUJ4ni+E5wVCeF4ohOdFQnheLITnJUJ4XiqE52VCeF4uhOcVQnj+TwjPK4XwvEoIz6uF8LxGCM9rhfC8TgjP64XwvEEIzxuF8LxJCM+bhfC8RQjPW4XwvE0Iz9uF8LxDCM87hfC8SwjPu4XwvEcIz3uF8LxPCM/7hfB8QAjPB4XwfEgIz4eF8HxECM9HhfB8TAjPx4XwfEIIzyeF8HxKCM+nhfB8RgjPZ4XwfE4Iz+eF8HxBCM8XhfB8SQjPl4XwfEUIz1eF8HxNCM/XhfB8QwjPN4XwfEsIz7eF8HxHCM93hfB8TwjP94Xw/EAIzw+F8PxICM+PhfD8RAjPT4Xw/EwIz8+F8PxCCM8vhfD8SgjPr4Xw/EYIz2+F8PxOCM/vhfD8QQjPH4XwXCGE50ohPH8SwvNnITx/EcLzVyE8fxPC83chPFcJ4fmHEJ5/CuH5lxCeq4Xw/FsITy1QAs80ITzThfAMC+EZEcIzQwjPTCE8mwjh2VQIz2ZCeDYXwjNLCM8WQni2FMKzlRCerYXwbCOEZ1shPNsJ4dleCM8OQnhmC+HZ0RHPdA/PVH9XvS+jzp2E6JzGqHPnf6Gduwjxwa5pqdefKo3m5RUW57nk2U1IG4ow6ty9kXSOpnapDdL46u+EDBl+s6EQ22zEaJvdM2TonMOo83Ih7bGHkP6mpxCevYTw3FgIz95CePYRwrOvEJ79hPDsL4TnACE8BwrhOUgIz8FCeA4RwnOoEJ5RITyVEJ65QnjmCeGZL4RngRCehUJ4FgnhGRPCs1gIz2FCeA4XwnMTITxHCOG56b9wf23kv1DnUf9CnUcL8cHNGNbfS5FXES3Kd8lzzL9wT3GskH2rcYx7ODsL2cMZL8S/JwjhOVEIz0lCeE4WwnOKkBi3OWOMGyIkxm0hpA1tKYTnVkJ4ThXCc5oQnlsL4TldCM9thPDcVgjP7YTw3F4Izx2E8NxRCM+dhPDcWQjPXYTwnCGE565CeO4mhOfuQniWCOFZKoRnmRCe5UJ4VgjhWSmE50whPGcJ4TlbCM89hPDcUwjPOUJ4zhXCc54QnvOF8NxLCM8FQnguFMJzkRCeVUJ4LhbCc4kQnnsL4bmPEJ77CuG5nxCe+wvheYAQngcK4blUCM9lQngeJITnwUJ4HiKE56FCeB4mhOfhQngeIYTnkUJ4HiWE59FCeB4jhOexQngeJ4Tn8UJ4niCE54lCeJ4khOfJQnieIoTnciE8TxXC8zQhPE8XwvMMITzPFMLzLCE8zxbC8xwhPM8VwvM8ITzPF8LzAiE8LxTC8yIhPC8WwvMSITwvFcLzMiE8LxfC8wohPP8nhOeVQnheJYTn1UJ4XiOE57VCeF4nhOf1QnjeIITnjUJ43iSE581CeN4ihOetQnjeJoTn7UJ43iGE551CeN4lhOfdQnjeI4TnvUJ43ieE5/1CeD4ghOeDQng+JITnw0J4PiKE56NCeD4mhOfjQng+IYTnk0J4PiWE59NCeD4jhOezQng+J4Tn80J4viCE54tCeL4khOfLQni+IoTnq0J4viaE5+tCeL4hhOebQni+JYTn20J4viOE57tCeL4nhOf7Qnh+IITnh0J4fiSE58dCeH4ihOenQnh+JoTn50J4fiGE55dCeH4lhOfXQnh+I4Tnt0J4fieE5/dCeP4ghOePQniuEMJzpRCePwnh+bMQnr8I4fmrEJ6/CeH5uxCeq4Tw/EMIzz+F8PxLCM/VQnj+LYRnKF0GzzQhPNOF8AwL4RkRwjNDCM9MITybCOHZVAjPZkJ4NhfCM0sIzxZCeLYUwrOVEJ6thfBsI4RnWyE82wnh2V4Izw5CeGYL4dlRCM9OQnh2FsKzixCeXYXw7CaEZ3chPDcQwnNDITw3EsIzRwjPHkJ49hTCs5cQnhsL4dlbCM8+Qnj2FcKznxCe/YXwHCCE50AhPAc54pnOzHMw4ZkXLczPryjKrVB5qiSaW1waK4jmF5QWxlRMFcQKynNjeXkVsfxYUXFpcVG0WOXnVajKguK8yriwwRludI54dAbPvBR4qi3DHp3Lk5e1VXid+lPJypoa5rNFqyaNZotqntHkdJ5m1zmajKyt66i/4kr/sqYz2qJ1Y9uimmfMr87b1KdzkT9Z29Zbf/mVfmRtx2iLNuvHFtU88xPXefuGdS5IVNYOidRfNDFZOzLaou36tEU1z2giOu+UqM5FDcvaOfH6K2tI1i6Mtmi3/m1RzbOofp1n+NM5tz5Zu/qtv6K6Ze3GaIv2QbFFNc+iunTePRmdY3ZZJcnVX8wmq5TRFh2CZYs1PAsr19W5LHmdo15Z5anUX25tWRWMtsgOoC3iPKNU58pUdc6vkTUz9frLNbJmMdqiY3BtsYZnRTVRNTvMIatSS1N7MMmCNLUnoy06BdwWhuecMN+6BeP8VtH5Wao6dm4kW0RTuxTjPEgxjuNVO0ZbdBFiC8bxnmIcr6hsRlt0FWILxn5NMcZl1ZnRFt2E2GII3xq6YowFirEtK1e2SGe2xVDGfYIvhezhRIXwVEJ45jbSnliq7bMPo855QvYB8xn9+7QMGe2xQIjfFArhWSSEZ0wIz2IhPIcJ4TlcCM9NhPAcIYTnpkJ4jhTCc5QQnqOF8NxMCM8xQniOFcJznBCe44XwnCCE50QhPCcJ4TlZCM8pQnhuLoTnFkJ4bimE51ZCeE4VwnOaEJ5bC+E5XQjPbYTw3FYIz+2E8NxeCM8dhPDcUQjPnYTw3FkIz12E8JwhhOeuQnjuJoTn7kJ4lgjhWSqEZ5kQnuVCeFYI4VkphOdMITxnCeE5WwjPPYTw3FMIzzlCeM4VwnOeEJ7zhfDcSwjPBUJ4LhTCc5EQnlVCeC4WwnOJEJ57C+G5jxCe+wrhuZ8QnvsL4XmAEJ4HCuG5VAjPZUJ4HiSE58FCeB4ihOehQngeJoTn4UJ4HiGE55FCeB4lhOfRQngeI4TnsUJ4HieE5/FCeJ4ghOeJQnie5Ihnuodnqs9BZzDqfLIQnTMZdT5FiM5NGHVeLkTnpow6nypE52aMOp8mROfmjDqfLkTnLEadzxCicwtGnc8UonNLRp3PEqJzK0adzxaic2tGnc8RonMbRp3PFaJzW0adzxOicztGnc8XonN7Rp0vEKJzB0adLxSiczajzhcJ0bkjo84XC9G5E6POlwjRuTOjzpcK0bkLo86XCdG5K6POlwvRuRujzlcI0bk7o87/E6LzBow6XylE5w0Zdb5KiM4bMep8tRCdcxh1vkaIzj0Ydb5WiM49GXW+TojOvRh1vl6Izhsz6nyDEJ17M+p8I6PO+jyA+a2IQUT/tHgdhOP/1/vnej9Z76/q/Ua9/6b3o/T+jN6v0Ov3ej1br+/q9U69/qfXw/T6kF4v0esHej6t55d6vqXnH3o8rsenerymxy+6P9f9Ww6g45+OB9o/dHvR9affBd8X6Af0BwYAAwnnI9Jr9BgMDAGG6joCFJCr7QjkAwVAIVAExIBiYBgwHNgEGAFsCoyM2200sBkwBhgLjAPGAxOAicAkYDIwBdgc2ALYEtgKmApMA7YGpgPbANsC2wHbAzsAOwI7ATsDuwAzgF2B3YDdgRKgFCgDyoEKoBKYCcwCZgN7AHsCc4C5wDxgPrAXsABYCCwCqoDFwBJgb2AfYF9gP2B/4ADgQGApsAw4CDgYOAQ4FDgMOFzXN3AkcBRwNHAMcCxwHHA8cAJwInAScDJwCrAcOBU4DTgdOAM4EzgLOBs4BzgXOA84H7gAuBC4CLgYuAS4FLgMuBy4AvgfcCVwFXA1cA1wLXAdcD1wA3AjcBNwM3ALcCtwG3A7cAdwJ3AXcDdwD3AvcB9wP/AA8CDwEPAw8AjwKPAY8DjwBPAk8BTwNPAM8CzwHPA88ALwIvAS8DLwCvAq8BrwOvAG8CbwFvA28A7wLvAe8D7wAfAh8BHwMfAJ8CnwGfA58AXwJfAV8DXwDfAt8B3wPfAD8COwAlgJ/AT8DPwC/Ar8BvwOrAL+AP4E/gJWA38DOhikAelAGIgAGUAm0ARoCjQDmgNZQAugJdAKaA20AdoC7YD2QAcgG+gIdAI6A12ArkA3oDuwAbAhsBGQA/QAegK9gI2B3kAfoC/QD+gPDAAGAoOAwcAQYCigg5wCcoE8IB8oAAqBIiAGFAPDgOHAJsAIYFNgJDAKGA1sBowBxgLjgPHABGAiMAmYDEwBNge2ALYEtgKmAtOArYHpwDbAtsB2wPbADsCOwE7AzsAuwAxgV2A3YHegBCgFyoByoAKoBGYCs4DZwB7AnsAcYC4wD5gP7AUsABYCi4AqYDGwBNgb2AfYF9gP2B84ADgQWAosAw4CDgYOAQ4FDgMOB44AjgSOAo4GjgGOBY4DjgdOAE4ETgJOBk4BlgOnAqcBpwNnAGcCZwFnA+cA5wLnAecDFwAXAhcBFwOXAJcClwGXA1cA/wOuBK4CrgauAa4FrgOuB24AbgRuAm4GbgFuBW4DbgfuAO4E7gLuBu4B7gXuA+4HHgAeBB4CHgYeAR4FHgMeB54AngSeAp4GngGeBZ4DngdeAF4EXgJeBl4BXgVeA14H3gDeBN4C3gbeAd4F3gPeBz4APgQ+Aj4GPgE+BT4DPge+AL4EvgK+Br4BvgW+A74HfgB+BFYAK4GfgJ+BX4Bfgd+A34FVwB/An8BfwGrgb0APBNKAdCAMRIAMIBNoAjQFmgHNgSygBdASaAW0BtoAbYF2QHugA5ANdAQ6AZ2BLkBXoBvQHdgA2BDYCMgBegA9gV7AxkBvoA/QF+gH9AcGAAOBQcBgQP9mlf6tJP3bQfp3efRv3ujfgNG/r6J/b0T/lof+nQz9GxT69x30byfo3yXQ7/zX79PX76pf8x54QL+/XL8bXL93W7/TWr8vWr+LWb/nWL9DWL+fV7/7Vr9XVr+zVb8PVb9rVL/HU78jU79/Ur/bUb83Ub+TUL/vT79LT7+nTr8DTr9fTb+7TL8XTL9zS7/PSr8rSr+HaXdAvz9Iv5tHv/dGv1NGv69FvwtFv2dEv8NDvx9Dv3tCv9dBvzNBv49AP+uvn6PXz6jr57/1s9X6uWX9TLB+3lY/y6qfE9XPYOrnG/Wzg/q5PP3Mm36eTD+rpZ+DOgjQz+/oZ2P0cyf6mQ79vIQeb+lz/voMvT6frs9+63PV+syyPg+sz9rqc6z6jKg+M6nPEOozdfqMmT5zpc8g6TM5+oyKPrOhzzDoPX29x633fPUeqN4T1Htkes9I76HoPQW9xq7XnPUarF6T1Gt0es1Kr+HoNQ09x9dzXj0H1HMiPUfQY+YHQzVXD5LuHv9bUlVVMXevqpyq+Tkl5eU5e8+umpUzf0nFwso58/Uwac1Y1G+ZV0mZbvG/ZSVz5qwpsGhRxcKq3eaW7LNb6eyq3RbN3k+P6tYMCXwW+cB/kY/8F/nUf5HP/Rf5wX+RFf6L/Oa/yCr/RVb7L7L2hHbiRZr5L5Llv0gr/0Xa+C/SxX+Rbv6L9PBfpJf/IoP9Fxnqv0jMf5Fh/ouM8F9kpP8iE/0Xmey/yFT/Rbb2X2Q7/0V28F+kxH+RMv9FKv0XmeW/yAL/RRb5L7Kv/yL7+y9yJCli1tWmLi6dM7ssp7ykqiSnamFFRc7seeUV++SUz69YNK9vVc7ckqqyWXoEMa9ikV6mWTOvSlXG0Qwy9NjLXL2NjIXzl8yeNzNnr2pZS0rmLNZyyuYsXjR7/rycypLZcyr0OtWaAZvPuruMFEl0nHVrEmWe9FlGV+VT8fs2rim6Zi1TX6MXLizZN16Z8xdX5cyvzCmdv3he+SJacGCyBXOTLVicbMExyRZcGkq+Yg9J9kuPSrbgaUmwfSF+3yRStse6ZRctLq1aWFJWVbeALYmA9kaona8pMs2voqbg9v6/a6dkv2tOyH+lvhS/b3jiPE2RTf3yNAWnpMBzK/88t06WZ2kSPN+x6OirkRoBUxNX1BSZ7ldRU3BH/9+1S7LfNS/kv1I/jt/no5GaIr4bqSmYTCM1ZX00UlPEdyM1BZNppN9YdPTVSI0AH43UFPHdSE1BH43UFPHdSE3BZBrpylQrdaX/Sl2ZbKWu9F+pK5Ot1JUpVOof8ft8eL4p4tvzTcFkPN+U9eH5pohvzzcFk/H8jLR1dfTVSI0AH43UFPHdSE1BH43UFPHdSE3BZBppi3hZH43UFPHdSFtYDOiXp49Gaor4bqSmYDKNNDvVRprtv5FmJ9tIs/030uxkG2l2Co20e6qV2t1/pXZPtlK7+6/U7slWavcUKrVfvGzSU1IjwMeU1BTxPSU1BX1MSU0R31NSUzCZKekA/+F0QLLhdEAK4XSA/3A6INlwOiCFcJqfqufn+/f8/GQ9P9+/5+cn6/n5KXj+cP+NdHiyjXR4Co10uP9GOjzZRjo8hUY6NtVGOtZ/Ix2bbCMd67+Rjk22kY5NoZFOSbVSp/iv1CnJVuoU/5U6JdlKnZJCpU737/nTk/X86Sl4/nT/nj89Wc+fnoLnz0i1kc7w30hnJNtIZ/hvpDOSbaQzUmik5f4baXmyjbQ8hUZa7r+RlifbSMtTaKRzU22kc/030rnJNtK5/hvp3GQb6dwUGmlVqpVa5b9Sq5Kt1Cr/lVqVbKVWpVCpj8U32HP8fqkpONhXwebxO66P/9XPKZktfi1VP8c0Kv45mtqlmhJmrLJjRbn6Oasx8S8gRxTWfjb/M3/N9+tnscKh2v/LCtU83zU2nqef4eoaqvn/uHh+mOSNj+dFSN6EeF4GyZsYz8skeZPI9+hLf2zupK7yS5rGv5NddjQ3pmW3dCK7+rm7VqGa+oyQ78oi9daafH8a3/cr+v1Gtvkukx8h6S7kXnOfucf4Qkvyt0U83bqecs095VqRe1qQci095cxn4xsZpJx+7tC0ZxM9nLW/aG65tlVmqPaV5vkcIenmhFMTJ5yiSn9H57ismRVV1ce9xpZUlWyzsKJi++pzXWnkuw3/wR7+aaF1dTH30LgUtuia7qmPiOdzE0+ZJp5yTYlcbt9z2R60POO/xq+NHs2JvuYec56uTWjdi8oy5YytjMyWodox2tSdG/2q+70WDuuupafujB4tSB2YewY1UHct66g7GneySNrUnRv9orladiuHddfaU3dGDxrPzT15DdRd6zrqrgWpL1NnrUndudEvmteUcHVRd209ddfKUz8Rcs8wz/+8dde2jrprReqO9lf6SifyWnv0TCf30e9Mt8gxZdzVVzRfy27nRHa1LcxUxtjC6NGO1Km5Z6ylXkKEW3vymdrC3N+S1J25151+0dwsDyfzHSEPz5BHZ80p2wmn3FgW+Z5EOGUTTh2ccKruZ7LJdzLJXdP3d3RUj2lEtqmzjh476rru5MnT5cx4zbR5c09HUtd0DM49F+jskW2+qzPRxaR3iP9tRXjStmnyQh5d6Hh9GpHR3lJHRu/2RG5ddZtOZJm8DkSWma+GyffvGk877FfWtId25DsjhAvtV8w9S8i9ZmGwJfl/e6JTK0v9mDwjt5WnflqS76X9dBtPuTaecjRmRSwcsshfOj4weWa81ZbkGfu0JnmmDdnaQRuSZ+xI6yPi0YvavQXJ844BdZ6Ze9A2Y+a02SSvWTxtODULubePw/FogY2Tt87SSF1leu6h40pzz7L4X1t/bN4bxK9L9bjB2Mw7hmtGeJp7Dq2HJ5VlytnGcHQu71i/NbEk7NEvw6KfuefoevRb40Nx0rQPyiBrfrY4oP8daepGP+2D5xJ+pp4zm9Z8d1MndVvd/3nXMOjaXCj+2TuPdzhOVLa4bLjQ76zLN2n/Yu453fM/etF+mMZQU7a95Tu98mk/7PWNLAs32g+v4R6/+Xzy/wtJedMWwmQd+jrL/0OEa8jDdW2atisnbbp6jbcZ4Roh30W/vzn5fu5xXTOPbPNdzYivm/S1pN6aN61db6bODX8d/5rE05S/t1ymp1wrck8TUq6pp1xTz/6Hrr9LSNrYXce++fG0zP2e/ML69nv87OlQX/Pu6dB18TRSX5lO6is36i5eV8t2089GFR0PhkK168tcNI4YHfU4NpvUty5k5OQQOd7Y2cQjh46h6f6Ad13U3EPjrHc/Z1T8czS1S9HvN7LpOMjoYtJdyP/M3MDwTQ/Vni8YmelxmS0s/zN5IY/uNDbQOVwzz/3NPPe721vIdbm3EHU4F1jT7uleg/mOkKcuzWV0NO0+QgoZOTlEjnctPssjJytUey5oytGxAl2/puv1dO2Tu9238cj2rsPScfJAwq0VqR99pZM86qcmv7Xlf941eCrL1ElPcn9DfuJwfV7RPilEviPk4RTy6Okwbq35fbWI5ftaO6yDlqHE64DanO6BO+YZpWNxumcUc/7dudZzD14udP41ity7STyt6ypM7tUXbX/0HIv3PrNm4+2/vOuA3HHEe47Du85D/Xsc0XkW4efGJqqS2iTNwyWD5BvO3rkmtZu5Z3L8b13rK9643orINvrSeS63PdoSzpQP3WMy92zVgC517R02tcjaOkFZppwZA9L2asq2TYADHefQNVxaxravtkMDPNvX8X3NLbJ2TlCWKWf6f6qzd4+OtlmzR+qtF+/+FHcbau+R3cHDm9aBWc/X9TWTlKN+ZtOB9mF0n93VuTDaF7W2cG6cmFT7fJqpS2+8qS8mURuYe+bG/9a1JuotS/vECqKz9DWGNIvu3jUG73rCWMsZ0XFkDUlfbcl9dMyZ4aS+qudDTRzKdrXe7PfMoNHRtsZg5OQQOd75b6ZHDp3r0fUfM18wMd3cY+R5z8Nyx9MWHtnmu+jZL5Omawx0DqmvdJJH5+JmrpVl+Z/3nB2VZeqEjg+9+0NNPfe7Wweobj90v8J8R8jDKeTRk3IKhXjnWba9ETfnsqv1p23cfEdd+tPxRDMLz6CsqbSwcAqFePv2LMt3uTrjTudkdP1yoPO6V1G61mriWcSjO927KiT3DiWcjV/T87YmbdoSbY+0z2ziKZtVR1nDqwn5H41rdAzfog6dMsj3N8Y6cMTDh463zD1mvt7Q+VyvLk0sskYmKMuUyyTpUKj2Mwn0+QFvH+O9l/pv6wTKmau5pwyNkfQ5CZOm7cdNv1HtE941xYiHL7VppuceOs8392we/1uXXbzttb51hfralLlnagPfV9d6cROLrOkJyjLlTJuia9AtPDLomdxE2lRD5Vp7ZNAytD+jnLzr6HRtS1+j4n+jqVyq+vfSWlr4U3628/Uu54zeOOBtu/W1bxrbzD1lHp3o1VD/tjfR+b996cT3pfWVSerTu4ZLfXEBuY+2dzfzQuVw71lFXc8ZPMdj6h2L0rjinXMaOXQ+5J0/NfXIoXsjdF4t6RlI89hzXWMJk0fHtGbO2dLyv0Sea/Rz7srdvnZ128xyKNvRHETR8xQh8h0hT12ay+ho29f29vW0/Rg53j4+i9xPbe9dr7ed+22M/Q8j23wX3Rcx6SHxv3RsYRu3UD817d72TFND5811nfQm9zfkJ673dGn7MN8R8nAKefR0GLeide0JOHreS9HzuInUAW3LrRqPZ5Suq9J5wHDn3117bmV82suFzkc2I/eauW1d+9q251eqSBlvn7W+zsTY9oEnEM57EH6O2kAltUOahwtd625L8uqylbmnoTmuN5Z755xaX+9e4SgefRWN3d59Xbrfa+6Z1oAu7erQpZlF1jYJyjLl6FlJfdF93XYJcKBjmw5ELi1DdTb37NQAzw51fF+WRdaMBGWZct73YNDnhejeNPUd+rxvXc9/crch7z55toc3rYPy+F9dX7NJORpzbTrQfqsN0cvVuRva/7SxcG6kmFTr/I+pS2+8qS8mURuYe+Z7ytMry1LW2w9GyPdy1jntr+jadBXh5l2zruucFm37/7T1k/SQv/c4eW3GyDPf3R59df1mOpJN91joeMm7j+BSP/0d9HmpRNa39LzdzGH2Kinbc/TCmYvnVsyrWkQH1XQBi160IYVJntep6H1G6fSQ/fCH7YCAkW3+1yxU+2CVQIcspg7pPYCh9TGLlmObrltv5oVo4y3/My9Gm0D+ZybB5gVpEz3/S3QBlQbUcSTP8B9P8oz9JpA8U58TyYIsfWnIJM+qoG6c5nBFxbwFiysWV1S/QGr84nllVbPnzxtTMmdOyHPRyrS9DSpElPDeT5+2aWr5v7lMhdeVZyqWpv8BvUiMNlqv/v+SXiTvH96L5Hl7kQmWXmTCP6UXMUcthDpk6X+9SPU99HUekyzHQydbjodOshwPdbT0n+v3mBjdnnK1DaflmiUK/Su4UxfOXlJSVWH6Vtp/eZ9a9PZt9DL3BLUfTmT3SuI9zvrTaNTh6eZorpZn2kF9p6/MPT3if+ta9crw1BNdLdSXdi26ox/y1G9aHfWbTvh4+/90Iou23fQ6viuS4HcmandXb291ePJ8jd29b5HxPoEeIfeYnb+67O6NMcbuRmbL0Lq7F4nYgL55hL5ZuhnhbvK8J49p99eM/M30yKPfF7Lk0RiXZkmnh9aNzTRty8uyfE9bS563zXvl6YsOn/Q1Kv43muKlZdA24uVG2wd9Wi+Nn4siItd8p7cO2lrq5/8ErOzHIasEAA==","debug_symbols":"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"},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"portal_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"7Z3vjhw3ksTfRZ+NQ/E/6Vc5HBb2rnchwLAXtveAg+F3v5bVVTWzyp3oQTMpVga/2JJNsTNCE81fsVhZv3/42w/f/+sff/n4099//vXDt//9+4cff/7rd799/Pmn2+9+/+ObD9//8vHHHz/+4y8v//OH7c9//Jfb/vwTv/7zu58+/Ydff/vul98+fLt98+GHn/52+/ftT//9448/fPg2uz/+55tP4907x/t3jg/vHB/fOT69c3x+5/jyzvH14fHffDHMJefuI10K7hjschFGR+fSfXR0Pp6jXRVGZx/rfXT2+fXoz5W3pypP8ai8VlD5rdqwj/Y1n6NDE0bXtJtSm3819s+6/XbRut1F6/YXrTtctO44sO7gzrrLk3Wni9adp6j7cy1lolrqRLW0eWoJ20S1uIlq8RPVMvC7P2w7lbng0He/L+U+2Lez7rTdy46zlh13v30O59i2150uWne+aN3lonXXi9bdrll33C5at5v263vnfF+bULe/aN3zLpdv1z3tegnqnna9BHVPu16CuqddL0HdI9dLX466g4DUsc1TSxr5PduOWqJL4O/Tpdz20dmdhXjn75WHSSuvfv+xrXF79ZMojHXhGCv81KZIoDERaMwEGguBxkqgsdnXmDcCjY5A46z00lMjAefkSKCRgHMyAedkAs7JBJyTCTinEHBOIeCcQsA5hYBzSiTQSMA5hYBzCgHnFALOKQScUy2sHecNj1Q2QaOFtQNptPCdk+o+NrUoaLTwnYM0WvjOARqbhWsrpNHCtRXSaOHaKh9PTeQkrI/NwvqINFpYH5FGC9dWSKOFayuk0QLnII0WOAdptMA5QKPbLIAOFGmBdKBIAtRx27Ss8x/3MKSZw/7IuQvpfJz9OP3otsghc1ri6StzWujpK3Na7ukrc1r06StzWvrpKtNNyz/vkRm37Zw5SDKnJaC+MqdloL4yTVAQlhk5ZJqgICzTBAVhmSYoKJbj6bz4oo4XMk1QEJZpgoKgTG+DgqBMGxQEZdqgICjTBgVBmdGCzOTPOl48qvxCpgkKwjJNUBCWaYKCsEwTFIRlmqAgKDOYoCAs0wQFpZb3mfPWJJkmKAjLNEFBWGbkkGmDgqBMGxQEZdqgICjzehR0L/x6XPO58Hg9UrkXfj32uBd+PZr4XHgyccr77SdL3LSNzrqKJHgOyploigZFWjjpDUVaOOoNRZp4pg2JNPFQGxJp4qk2INJEa7S87RNn7yWRJk57I5EmTnsjkSaebEMio4UvnnaKDJJIE8SDRJogHiTSBPEgkSaIB4k0QTxApIkmaeAhd2eiSxoUaWKPB4k0sceDREYGkSaIB4k0QTxIJEHfImeiWRoUSdC5yFUG4qkMxFMZiMdGdz8kMjKIZCCeykA8DJ0aHUOrRsfQq9ExNGv0/dr7tARElrTfRSzlvGORjkrCNJXEaSpJ01Ty1AKV0/HC+JwLqCSGspcSQ3sRHVel+2DpeBl9Tqm8Gn0v/all57b/e5QOTfQ5HG8UvVUDRtfjGb36Ips+hr3wOq7w1I7Ci4NfV5tzfp98c+n8efHuKL5duPjn2rd87eLdlYv3Vy4+XLn4eOXi05WLz1cuvly5+CuvsO7KK6yfeIVN9Sy+uFfFC+NPirtdFp+1BL8rnXg57qx04rW7s9KJF/rOSiON0okRorPSiXmjs9KJ4aSz0olJprPSibGnr9JAw0iBhpECDSMFGkZ6ronIpZTSMFKgYaRAw0iBhpECDSNFGkaKNIwUaRgp0jBSjDRKaRgp0jBSpGGkSMNIkYaREg0jJRpGSjSMlGgY6bkmZZdSSsNIiYaRkpX11Lt8zO5y/FJptrKeYqVW1lOs1Mp6ipVaWU+xUivrKVZqZT3FSq2sp1iplT0HrNTKngNWSsNIhYaRCg0jFRpGKjSM9FzTrEsppWGkQsNIhYaRCg0jFRpGqjSMVGkYqdIwUqVhpOfabF1KKQ0jVRpGqjSMVGkYqdIwUqNhpEbDSG3eVca/aFzgfXyl9F78vAvHA8XP+71x2108i68Z/Iy9Pf5PsWGb96tDQey83x4KYue9yFIQO+91loLYyCR24nWwv9iJ183+Yue95lIQO+9ll4JYJoKauA2mglgmgpq4zaaCWCaCmriNp4JYJoKauE2oglgmgpq4DamCWCsE5W9btvvsN3r449/3OcPEPU57K7XCTt6X7VTqBaVWllefwv7Kkdsvq6DUytqKlVpZWLFSK6sqVmplScVKzaynSOnE/TB7KzWznkKlVjYisFIruxBYaaRRSsNIE3eJ7K2Uhhwm7hLZWenEHQXfqbTW40q8bdtLpV8ODtHtLTtCjMLF7MTtB7+qLWbWr762mFns+tpiZvegry1mgKGvLWbooq8tZlCkqy0Td278qraY2R7pawvlAl39/pbr6gX0n7gB39czZeJuZ4qmtOMuZhMaGIaJG6N9RVMo4+M2t51zB8EWSrrFtlDSLbaFkm6hLRP3CPuqtlDSLbaFklmwLZTUgm2JyxbJFspLRGwLKeWWo3DnhQ2FidurfVVbSCkX2UJKucCWibu8fVVbSCkX2UJKucgWUspFtsRli2QLKeUiWxblirYsyhVtWZQr2rIoV7Jl4j59X9WWRbmiLYtyRVsW5Yq2REpb/Fn4y26Opy2clAtt4aRcaAsn5UJbOCkX2sJJucCWaKalbGdbOCkX2sJJudAWTsqFtsRli2TLolzRlkW5oi2LckVbFuWKtizKlWwx0/a3sy2LckVbSBfodNqSimAL6QKNbCH9yj3n9vXLBprRTqvQvraQfuUiW0g3FpAtpBsLyJa4bJFsIeUWZAsptyBbSDcWkC2kGwvIlkW5ki12Gvj2tWVRrmjLolzRFgLKvSuNNEoJWPSulAAv70oJiPGulAAC70oJuO6z0kiAanelBPR1V0oAVHelNIzE0Kv6rpSGkew0w205H0qLoNROf1uo1Mw3UqvtPjxsmxeUmvlGgkrNfCNBpWau2qBSM1dtUKmZqzao1M56CpRmO+spUmrmqg0qtXLVVnbqLUlQaYWP3lYZKVRa4aK3VVphordVWuGht1VaYaG3VVrhoDdVmukq/rZKK/zztkoK9jHTq/ptlRRUYKaT9NsqKajATJ/ncD7DFXzIglIrZACVmunGjJVaIQSs1AolYKVWdkmw0kij1M4qk+qhNAs7mWZap0KlZvpbhuAOpSEIjGSmZSVWauYbCSq1cqWGlVq5WsNKrVyxYaVm1lOo1Mx6CpQmM30XsVIzV21QqR1Gqud72TdJqR1GQkojjVI7jISU2mEkpNQMI0V3Ko1eUGqGkaBSM4yElJrp2oeVmmEkqNQMI0GlZhgJKo00Ss0wElRqhpGgUhpGcjSMZKYnJ1Rqps0mVkrDSGaaYWKlNIxkpmUlVkrDSGYaS2KlNIxkpv0jVkrDSGaaNGKlNIz0XCvFsu138lxJ4VXt9+mD7vRRd/qkO33Wnb7oTl91p2+q0z/XxQxP73Sn101t1E1t1E1t1E1t1E1t1E1t1E1t1E1t0k1t0k1t0k1t0k1t0k1t0k1t0k1t0k1t0k1t0k1t1k1t1k1t1k1t1k1t1k1t1k1t1k1t1k1t1k1t1k1t0U1t0U1t0U1t0U1t0U1t0U1t0U1t0U1t0U1t0U1t1U1t1U1t1U1t1U1t1U1t1U1t1U1t1U1t1U1t1U1t001t001t001t001t001t001t001t001t001tU01t3jbd6Z3u9F53+qA7fdSdPulOn3WnL7rTV93pdVPrdFPrdFPrdFPrdFPrdFPrdFPrdFPrdFPrdFPrdFPrdVPrdVPrdVPrdVPrdVPrdVPrdVPrdVPrdVPrdVMbdFMbdFOrezYq656Nyrpno7Lu2aj83Nmoepx6czVur6aXzuvlfd7bgBfn9UrYi3kq4zUfWuuLA3tyMdGXfXR8ebzPfToa+MXoHNr+iogcXXw1+l76U98fNZazdHQ2Mba9ZWryWXKxPfdXGs9SmvAT89yJLjy9053e604fdKePutMn3emz7vRFd/qqO71uapNuapNuapNuapNuapNuapNuapNuapNuapNuapNuarNuarNuarNuarNuarNuarNuarNuarNuarNuarNuaotuaotuaotuaotuaotuaotuaotuaotuaotuaotuaqtuaqtuaqtuaqtuaqtuaqtuaqtuaqtuaqtuaqtuaptuaptuaptuaptuaptuaptuaptuaptuaptuaptqasu26U7vdKf3utMH3emj7vRJd/qsO33Rnb7qTq+bWqebWqebWqebWqebWqebWqebWqebWqebWqebWqebWq+bWq+bWq+bWq+bWq+bWq+bWq+bWq+bWq+bWq+b2qCb2qCb2qCb2qCb2qCb2qCb2qCb2qCb2qCbWt2zUUX3bFTRPRtVdM9GFd2zUUX3bFTRPRtVdM9GFd2zUUX3bFTRPRtVdM9GFd2zUUX3bFTRPRtVdM9GFd2zUUX3bFTRPRtVdM9GFd2zUUX3bFSRz0Y5548T7y5G8CH+OKntgivnh3x69dkXo1Mue/HpdmPoHC2eSE/JH6fAU0Ln1+vtDut9dC3+9ei7XM8lN3DJjVxyE5fczCW3cMmtXHKbLDcfClxDcsO2HXL9+aDZp3X+y/pDyXv9oRWk1vtjtE/Im5ri/pdUU9sEtfJRUbNqHZVaT6U2UKmNVGrTaLXHzCk6VP/ts3e1rqWXzxXv13IlX7z+cvH668Xrb9euv24Xr99dvP4eJJCPlx2FUl/Wf/+MMOAz4oDPSAM+Iw/4jDLgM+qAz2j6n9G2AZ/hBnzGgJy3ATlvA3LeBuS8Dch5G5DzNiDnTT/nddsGfIYb8Bl+wGeEAZ8RB3xGGvAZecBnlAGfUQd8xoCcuwE5dwNy7gbk3A3IuRuQczcg525Azt2AnLsBOXcDcu4H5NwPyLkfkHM/IOd+QM79gJz7ATn3A3LuB+TcD8h5GJDzMCDnYUDOw4CchwE5DwNyHgbkPAzIeRiQ8zAg53FAzuOAnMcBOY8Dch4H5DwOyHkckPM4IOdxQM7jgJynATlPA3KeBuQ8Dch5GpDzNCDnaUDO04CcpwE5TwNyngfkPA/IeR6Q8zwg53lAzvOAnOcBOc8Dcp4H5DwPyHkZkPMyIOdlQM7LgJyXATkvA3Le49xkisfglMvLzxDOXX3NJw9qj1OWF1JbqdQ2JrU9znteSK2jUuup1AYqtfF5tXk7DiPn4KdWm6jUZiq1hUptpVLbmNT2OJt+IbWOSu0zrZPSdtTiT0v+wys73fGi1OhejpbfNurj/m7S7HOUCn+mKVMK4TQRFb55vxe+RfTcaUl1L7xkv0mFP9WPKftjvyI3VLpPbR/ti6tgtNt82ZXefv3ijbDeBWF88GmXGnw+f3BvP/B3pdmM0rodSlsTlDYSpe251xZcSqmjUepplAYapZFGqZ31FCllWU/bc+8guZTSSqPUDCPd9O1KQ4hfKnVmGAkqNcNIUKkZRoJKzTASVBpplJphJKjUDCNBpWYYCSo1w0ghHDtmITlBqR1GAkq9HUZCSu0wElJqh5GQUjuMhJRGM0rdqTQkQakdRkJK7TASUmqHkZBSO4yElNphJKA02GEkpNQOIyGldhgJKbXDSEhppFFKw0iBhpECDSMFGkYKNIwUaRgp0jBSpGGkSMNIz72a+FJKaRgp0pBDpCGHSEMOiYYcEg05PPcq7YmU+pb3J4h8K5ug1Moqg5VauRLHSq2sp1iplfUUK7WynkKl2cp6ipVaWU+xUitX4liplStxrDRaocFt258oDrc/Kig1cyUOlZq5WwGVmtlzgErN7DlApWb2HJDSYoeR6nFme9u8oNQOIyGldhgJKbXDSEhppFFqZx8JKbWzj4SU2tlHQkrt7CMhpXb2kYDSSsNIlYaRKg0jVRpGqjSMVGkYqdIwUqVhpErDSJWGkRoNIzUaRmo0jNRoGKlFGqU0jGSmqy1WamY9rXVvVO3b9uqeuDC5T0fhPn15E8dtZnrg9vbFzFrd2RczK3tnX8xwQGdf4vJF9MUMY3T2xQyRdPbFzB7P+3w53vnhfBN9MbMj1NkXUt5FvpjpZ9zbF1Lehb6Q8i70hZR3z7l9dZIvcfki+kLKu9AXUt6FvpDyLvSFlHehL6S8i3wx05u6ty+kvAt9IeVd6MviXdmXuHwRfVm8K/uyeFf2ZfGu7MviXdmXxbuiL2b6jPf2ZfGu7MviXdmXxbuyL5T80to+trUkuUJJL9AVSnaBrlCSC3LFTO/vvq5QUgt0hZJZoCuUxAJdicsVwRXK3TnoymJbyZXFtpIri20lVxbbCq6Y6U7/vr2EzW3n3EHyhXNPDvvCuSeHfeHck8O+xOWL6AvnPWjsC+c9aOwL5z1o7AvnPWjsC+c9aOiLnbdHvM8XX4654yb5Qsq70BdS3oW+kPIu9CUuX0RfSHkX+rJ4V/Zl8a7ML4t3ZV8W74q+2HkTSGdf1v6u7Mva35V9Wfu7si9x+SL6svZ3ZV8W78q+LN6VfVm8K/uyeFf0xc5bXTr7snhX9mXxruzL4l3Zl7h8EX1ZvCv7snhX9mXxruzL4l3Zl8W7oi923tDT2ZfFu7Ivi3dlXxbvyr5Q8kv1e4vd6qvkCiW91Jh3V3KWXKFkF+gKJbkAVxznu2qgK5SrEHQlLlcEVyh3XKArnLyCXFm8IrmyeEVyZfGK4Arnu2mgK5S7LNAVTrataXelVckVTrZFrsTliuAKJ9siVzjZFrnCybbIFU62Ra5wsi1whfM9NNAVTrZFriy2lVxZbCu5EpcrgiuLbSVXFttKriy2lVxZbCu5sthWcIXznTPQlcW2kiuLbSVXFttKrsTliuDKojjJlUVxkiuL4iRXFsUJrnC+gQe6MvHKHNvpSqqvXNmrn3gFfaD6iXdxHqh+4nX6geonXk8fqH7ide+B6iden3D1M7/t4oHqJ75qf6D6ia+uH6j+0mvtzG9heKD6S6+1M7/R4IHqJ15rQzqrj6+rl2rZzlrcS053h9aJV+buWidex3trnbnnf3etEzNCd60TE0V3rRPzR3etkUjrxGzTXevEJNRdKxE3zdyTvrtWIm6auXd8d61E3DRzj/fuWom4aeZe7N21EnHTzD3Tu2sl4qaZe5t312qGm+J2vNIrhld38O9SZ25B3luqGWoKNZxSnSTVzuKa3FFL8pJUO2srlGpnaYVS7aysUKqdhbXtrUZuV6hNkmpnPwJJnbnVcW+pdnYjoFQ7mxHnSdDiJVpqZtbVWo7h9UUtL6Ra+Qa+XcLsVXsndUh2M/d37SvVb1a+gR+QauUb+AGpVr6BH5BqZTf4AamRR6qVdfUBqVauVx+QauV69QGpNLTkZ+4u21nqzC1je0u1Q0v5mN3lKEm1Q0tQqh1aglIjj1Q7tASl2qElKNUOLUGpdmgJSrVDS0jqzE1Ie0vloaWZ24X2lmrnrjm4keFnbtbYW6qdu+ZQqpm75tUfNx1rkq5XZ+6V2FnqzA0Qe0s1c9ccSzVz1xxLNXOCH0uNPFLtnIWAUs3QEpZqhpawVB5amrknYWepMzca7HtEy0c7tASl2qElKNUOLUGpkUcqzclRP3Nryt5S7dASlGqHlqBUO7SEpM7cTrO3VB5amrlRZ2+pPLQ0cwvQ3lLNrKvpuOnoUn31pOOXg0N0+9whRi/5YmYR7uyLmRW7ry92+mZ29sUMC3T2xQw4dPbFDGV09iUuX0RfzOz2dPbFzNZQX1/s9Gl8jy/Vx/vY6qvkCuUqDV2hvDZqbe8Y08QrRjud2Hq6Yqe713tccdvxtNunz5F8oeTcB3yh5NwHfInLF9EXSs59wBdKzn3AF0p2ecAXSnp5wBfKfV3si51Gep19IeXdcgx2XtpfsNOir7MvpLwLfYnLF9EXUt6FvpDyLvSFlHehL6S8C30h5V3gSzDTtrS3L4t3ZV8W78q+LN6VfYnLF9GXxbuyL4t3ZV8W78q+LN6VfeHkXX8W7r3QiSqYaTzb2xdO3sW+cPIu9oWTd7Evcfki+sLJu9gXTt7FvnDyLvaFk3exL4t3RV/MtA7u7cviXdmXxbuyL4t3ZV/i8kX0ZfGu7MviXdEXO62I3+dLOn1JRfKFdJ2GvpB+756N2n11ki+k37vQF9LvXegL6T4D9IV0nwH6QrrPgHyx0xy4sy+k/AJ9Id1ngL6Q7jNAX6J9X3apdhC21aMWJ/6t2qFSKNUOaEKpdtgRSrWDg0iqnYbGWKodaINS7XAYlGoHraDUyCOVh5YSDy0ZalMNpZqhpZzcUUuSrmzsNJOGUu30h8ZSzdASlmqGlrBUM7SEpUYeqXZexA6l2nkRO5Rq50XsUCoPLZlpXe3dseV9+6V0+slMP+oHpFpBiAekWkGIB6RGHqlWEOIBqVYQ4gGpVhDiAalWEOIBqVY2XLDUykNLZt498IBUHloy84aAB6RGHqk8tGSmNf8DUnlo6aIN9PfqrwlA9+ov2ox+r/6amLJXf03y2KsnfQwKPTZH2k4b+0L6GBT0hfQxKOgL6WNQwJdI2k4b+7Ie45Z9IX0MCvpC+hhUjYcvTfQlLl9EX0h5F/pCyrvQF1Lehb6Q8i70ZT32Lz2WG1nbaUNf1mP/si/rsX/Zl/XYv+xLXL6Ivqw2V7Ivq82V7MtqcyX7stpcyb4s3hV9YW2nDX1ZvCv7snhX9mXxruxLXL6IvizelX1ZvCv7snhX9mXxruzL4l3Rl0DJL63tj+a2F2W/cIWSXqArcbkiuEJJLtAVSm6BrlBSC3SFklmgK5TEglzhbEMPXaHcnYOuLLaVXFlsK7kSlyuCK4ttJVc49+Q2t51zB8kXzj057Avnnhz2hXNPDvpiqBF/X18470FjXzjvQWNfOO9BY1/i8kX0hfMeNPaFlHd9OeaOm+QLKe9CX0h5F/pCyrvIFzuvUujsCynvQl8W78q+LN4V+cXO6x86+7J4V/Zl7e/Kvqz9XdmXtb8r+7L2d0VfzLz3o7cva39X9mXxruzL4l3Zl7h8EX1ZvCv7snhX9mXxruzL4l3Zl8W7oi9m3tzS25fFu7Ivi3dlXxbvyr7E5Yvoy+Jd2ZfFu7Ivi3dlXxbvyr4s3hV9ueibZZ70pfq9xW71VXKFkl5qzLsrOUuuxOWK4AoluUBXKNch6ArlKgRcSZzvqYGuUO64QFc4eQW5snhFciUuVwRXFq9IrlDus0BXKHdZoCucbFv3qWurkiucbAtc4XwnDXSFk22RK5xsi1zhZFvkSlyuCK5wsi1yhZNtkSucbItcWWwrubLYVnCF8/0z0JXFtpIri20lVxbbSq7E5YrgymJbyZXFtpIri20lVxbbSq4sthVcCYttJVcWxUmuLIqTXInLFcGVRXGSK4viXrnyx+13//vdLx+/+/7HH369/YlP//NfP/31t48//3T/7W//98/P/+c2+P8B"},{"name":"claim_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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sRaTiD7WYhLRxxpMlohrsfHs0ZvfknMPJhGvscazR0vEa6zFRPoaaz1dsEqnevPspfO3efbSSdk8e+l11Dx76RXPPHvpnGievXSiM89e2hdYz2Ot0iu49UzQqr3WGmdftNda6+zfvdaux9Nk6en+Zoj72e9+L0Vo1hOs38Y6w/ptrGdYv431Auu3sV5h/TbWBdZvY73B+l2s3/1eitCsyY3vY01ufB9rcuP7WGdYv401ufF9rMmN72NNbnwfa3Lj06G/mYTMd18+P5GHkDnMYBIyLxlMQuYag0nI/GEwyRGZfPlMSR5C+nmDSUjfbTAJ6Y8NJhF97NfPT+Qhoo81mIwRfazFJKKPtZhE9LEWk4hr8dfPHuUx4lpsMEkRr7FfP3uUU8RrrMVE+hprPF2Qk3SqN88+3/rspZOyefbS66h59tIrnnn20jnRPHvpRGed/STtC4znsfIkvYIbzwTlSXuttc5ee621zv7Na+08jfvZL8V6mmwa8370NJb1cfZpP/v51me/3Prs11uffbn12W93Pvt370Hf+OzHW599uvXZT7c++1uvtfnWa22+9Vqbb73W5luvtfnWa+1867V2vvVaO996rZ1vvda+e1/gxmd/67V2vvVaO996rZ1vvdbOt15rl1uvtcut19rl1mvtcuu19t37/jY++1uvtcut19rl1mvtcuu1drn1Wrveeq1db73Wrrdea9dbr7Xv3nG48dnfeq1db73Wrrdea9dbr7Xrrdfacuu1ttx6rS23XmvLrdfad+8z2/jsb73WlluvteXWa2259Vpbbr3Wbrdea7dbr7Xbrdfa7dZr7bv35mt89rdea7dbr7Xbrdfa7dZr7XbntXYe7rzWzsOd19p5uPNaOw93Xmvn4c5r7Tzcea2dhzuvtfNw57V2Hu681s7Drdfa8dZr7XjrtXa89Vo73nqtHW+91o63XmvHW6+1463X2vHWa+1467U23XqtTbdea9Ot19p067X23ftGNT77W6+16dZrbbr1WptuvdamW6+1063X2unWa+1067V2uvVae+t9o+Zb7xs133rfqPnW+0bNt943ar71vlHzrfeNmm+9b9R8632j5lvvGzXfet+o+db7Rs233jdq1t43Ko37bu1TmsbK2UuvtebZS6+11tlr7xtlnr30WmuevfRaa5699Fprnn2DtXbbT2jJef767MftOJ9x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eu+WpM6zBvJNUz++KaXH93enXJu1H99kz9qPb7Jn7cc3mbPmfnyTPWs/vsmetR/fZM/aj2/6Y9atNmsONGs/vinlfMz6/D2Gx6wd+SZz1o58kzlrR77JnLUj32TNOnfkm8xZO/JN5qwd+abnWdfarD35pvkxa6nN2s/6Oi37tyfHaZ1rs/azvtqz9rO+2rP2s76asy79rK/2rP2sr/as/ayv9qz9rK9TGY5ZS219fe8G7c6z9tNL2LN25JvMWTvyTeasHfkmc9aOfJM163t32Xs85bkMyZh1GvP+ZoRpLE95NB3nnm587tONzz3f+NznG5/7cuNzX2987uXG577d99zfu09V43O/8bq63Xhd3W68rr53P6XG537jdXW78bq63Xhd3W68rm73XVfn4b7r6jzcd12dh/uuq/Nw33V1Hu67rs7DfdfVebjvujoP911X5+G+6+o83HhdHW+8ro43XlfHG6+r443X1ffucdT43G+8ro43XlfHG6+r443X1fHG62q68bqabryuJt11NY37wVOaxtq5666r9rnrrqv2ueuuq/a5666r9rnrrqv2ueuuq/a5666raTo2GkzzUDn3SXddtc9dd121z114XTXPXXhdNc9deF01z114XTXPXXhdXebj3Netdu7C66p57sLrqnnuwuuqde5ZeF01z114XTXPXXhdNc9deF19OvdqT/DePUYan7vwumqe+1vX1WXcl/nlaZU/e07hOHgc8h/n/vngnKdjU/9c/+NYowxaogy6BRn0vft+eA46Rhk0dTLo9ngn8lBbXt673YfnoDnKoHOUQXtxRuagvTgjc9CfO6Ntv9255Dx/Pei4Hb3/uD2/nbD+lO0wjsc2x8P4vE/UOB0DbDcfoMEOK84DjHcfIN19gOnuA+S7DzDffYDl7gOsdx/g7ivxcveVeNVeiefyGGAdrePLeuzEWLbHqUyH81u1l+3W02qv8a2n1TYErafNoabVthqtp9X2Ja2n1TYxrafVdjytp9W2R42nLaG8VAnlpUooL1VCeakGe9DdadpQXqqE8lIllJcqobxUCeWltlBeagvlpbZQXmoL5aUa7Dt4p2lDeaktlJfaQnmpLZSX2iJ5qWWI5KWWIZKXWoZIXmoZInmpZcihpu1ovU3jsn8H9eM/c23ajtbbC9N2tN7a044drbcXpu1ovb0wbUfr7YVpO1pvL0zb0Xp7YdqOuosL03bUXVyYNpSXGkN5qTGUl0qhvFQK5aVSKC+VQnmpBvuO3mnaUF4qhfJSKZSXSqG8VArlpaZQXmoK5aWmUF5qCuWlGuw1e6dpQ3mpKZSXmkJ5qSmUl5pCeaksvQKlpwf/U8p/HL8PIL2oXBlA+lqS1qcByvKj4/eBpS8nrxhY+orygoFn6YD2ioGlM9orBpaOaa8YWHudfMHA2uvqCwaWzmuvGFg6sr1i4GhOS3uD0FcMHM1paW9A+oqBozkt7Q1OXzFwNKelvYHqKwaO5rS0N2h9xcAdOa2UjlNJ0/hoXB8dqvbur82n7chjpbQOj2lTZVrtvUf/ctp52j/94z9LbdqO1t4L03a08F6YtqNV98K0HS25F6btab21p+1pvbWn7Wm9NafV3nu0+bQdtRkXpg3lpbT3Hm0+bSh3ob0bZ/NpQ7kL7R0b/3LaUo40vw3D87SfD57yMeOUcy0Ma2/v6Iump7WtMZqeFsLGaDJoztD0ZCgao+nJfTRG05NVaYymp9akMZqeKpamaFbtnQpfiKakvI+YSg1M1KXbAqO9a9wLwWzHaW+1jSFX7Q3mPMFE/VMah3F4fPZUQxPVBV9AE9UFX0AT1QVfQBPVBV9AE9UF22i0d2/zRRPV1VxAE7UTvoAmaqy8gCaHRbPumxWMY6qVEdrb0/miieuGTTRx3bCJJq4bNtHEdcMWGu3993zRxHXDJpq4bthEE9cNm2gyaM7Q4IZP0eCGT9Hghk/R4IZP0eCGz9Bk3PApGtzwKZqwbjilA83zjphPaMK6YRtNBs0ZmrBu2EYT1g3baMK6YRtNWDdsownrhk00PW392xpNWDdso8ENn6LBDZ+iyaA5Q4MbPkWDGz5Fgxs+RYMbPkWDGz5D09Netn+JZn6gmdcamriLt4km7mX48dnp18l+RhP3MmyiiXsZttCscUsJE03cUsJEE7eUMNHE9TUmmgyaMzRxSwkTTdxSwkSDGz5Fgxs+RYMbPkPT1RbLjdHEcMP7tDEM7j5tDM+6T5tDTRvDWe7TxjCL+7Qx/N8+bQxLt08bw6X9njbIzuL7tKG8VJD9v/dpQ3mprjYV3pblmHatTtvTCmRNW4aerlIfH/n78GkYUm3anq5S9rQ9XaXsaXOoaXtKfPa0PSU+e9qu1ltz2q7WW3PanhKfOW1Pe6Gv+4msc23SjnyUMWlHHsqYtCP/ZEyaw0zakW8yJu3IMxmTduSXjEk78krGpB35pK8n7WlvdWPSMM6hp+29jUlzmEnDOIee9tKeHs+oTWlaatN25B4uTNuRg7gwbUcuwp62p32pL0zbUeNyYdqOvNOFabtageZyTLvUWtKetqS1p+1pv9BpGo9pp6nmpXraAvTCtD1dpexpO0p5F6bNoabtKO1dmLan9daetqf11p62p8RnT9tT4jOn7Wm3yWkq+2lPeahO25WXMqftykuZ03blpcxpc6hpe/JSeXxMm2v5tqf9FS9M25OXsqftyUvZ0/bkpcxpl568lD1tT17KnrYnL2VP25OXsqfNoaYN5aWWUF6qp31PL0wbykv1tDupPW1PG45emDaUl+ppW9AL04byUj1t3nlh2lBeqqctNi9MG8pL9bQR5oVpQ3mpn29Xmde8Tzvn5etp01D2g1NKxZx2HB/TjnP64/h9gPHuA6S7DzDdfYB89wHmuw+w3H2A9e4DlLsPsN18gO3uK/F295V4016Jj6++f/z3OlrHf+TP/fCy1b43sWkv262n1V7jW0+rbQhaT6vtHlpPq201Wk+r7UtaT6ttYtpOuw3ajqf1tNr2qPW0kbzUNkTyUtuQQ00byUttQyQvtQ2RvNQ2RPJS2xDKS42hvNQYykuNobzUGMpL/Xxv1FtNG8pLjaG81BjKS42hvNQYykulUF4qhfJSKZSXSqG81M93i73VtKG8VArlpVJH620al30/xo//zJVpp47W2wvTdrTeXpi2o/X2wrQdrbcXpu1ovb0wbUfr7YVpO1pvL0zbUXdxYdqOuosL04byUjmUl8qhvFQO5aVyKC/18/2PbzVtKC+VQ3mpHMpL5VBeKofyUnMoLzWH8lJzKC81h/JSP9//+FbThvJScygvNYfyUnMoLzWH8lJLKC+1hPJSi/QKlJ4e/E8p/3H8PoD0onJlAOlryd/tWfX18b8HXqUvJ68YWPqK8oqBpQPaKwaWzmivGDhHG1h7nXzBwNrr6gsGls5rrxhYOrK9YuBoTkt7g9BXDBzNaWlvQPqKgaM5Le0NTl8xcDSnpb2B6isGjua0tDdofcXAHTmtlI4t4dM0PhrXR4eqvftr82k78lgprcNj2lSbtqPlN83T/r6Cj/8stWk7WnsvTNvRwnth2o5W3QvTdrTkXpi2p/XWmHYbtPcebT5tT+utPW1HhcaFaTtqMy5Mm0NNG8hLfUwbyF18TBvIXXxMG8pdaO/Y+JfTlnKk+Q8dn6f9fLD1wrkPND0tV43R9LS2NUbT00LYGE1PDURjND0ZisZoenIfjdH0ZFXaotHeGdMXTU8VS2M0URfvkvYzKakWE7Q3NXQEo71r3AvBbMed062yMeQHmKjpyQQT9U9pHMbh8dlTDU1UF3wBTVQXfAFNVBdso9HeY80XTVQXfAFNVE9zAU1UV3MBTQbNGZqosfICmrhueN03KxjHVCsjtLen80UT1w2baOK6YQuN9i55vmjiumETTVw3bKKJ64ZNNBk0Z2jiumETDW74FA1u+BQNbvgUDW74DI32Poe+aHDDp2hww6docMOnaHJUNCkdaJ53xHxCE9YN22jCumEbTVg3bKMJ64ZtNGHdsImmp216W6MJ64ZtNGHdsI0mrBu20WTQnKHBDZ+iwQ2fosENn6LBDZ+iwQ2foelpK+XWaHDDp2jiLt7zA8281tDEXbxNNHEvw4/PTr9O9hOarrZabYwm7mXYRBO3lDDRxC0lTDQZNGdo4voaE01cX2OiiVtKmGjilhImGtzwCZqxq42QG6PBDZ+iwQ2foonhhvdpc6hpY3jWfdoYNnSfNoaz3KeNYRb3aWP4v9/TjjEs3T5tDJe2TxvDeO3ThvJSQfb/3qcN5aW62lR4W5Zj2rU2bVf7BNvT9nSV2sr2+/BpGFJt2p6uUva0PV2l7Gl7Snz2tD0lPnvanhKfPW1X66017dTVemtO21Pis6ftKPGtu0te59qkHfkoY9IcZtKO/JMxaUfeyZi0I99kTNqRZzIm7cgvfT1pT7u3G5N25JOMScN4pJ72AzcmDeMcetqt25g0jHPoaS/t6fGM2pSmpTZtR+7BnranHa8vTNuRi7gwbUdO4sK0HTUuF6bNoabtagWayzHtUmtJe9qS1p62p/1Cp2k8pp2mmpfqaQvQC9P2dJWyp+0o5V2YtqOkd2HajtLehWl7Wm/taXtab81pe9rH8sK0PSU+e9quvFTZT3vKQ3XarryUOW0ONW1XXsqctisvZU7bk5fK42PaXMu3Pe2veGHanryUOW1PuyBemLYnL2VP25OXsqftyUvZ0+ZQ0/bkpexpe/JS9rShvFQJ5aV62vfUnranrUwvTBvKS/W04eiFaUN5qZ62Bb0wbSgv1dPmnRemDeWletpi88K0kbxU6mkjzAvTRvJS6ZV7u+0/orz+R2wv/xGv3Dps/xHj639Eev2P+LFfXYZ9W5llydn4+1mOpw3SOjx923OcK0fP63Ea8zrPX3/0OGzD/rc2psE4OO2nMc7DH2exY8lgqWGZwVLDsoClhmUFSw1LAUsNywaWCpafb0HXJ5YRLDUsCSw1LLjcKpYMlhoWXG4VCy63igWXW8WCy61iweXWsEy43CoWXG4VCy63igWXW8WSwVLDgsutYsHlVrHgcqtYcLlVLLjcGpaMy61iweVWseByq1hwuVUsGSw1LLjcKhZcbhULLreKBZdbxYLLrWGZcblVLLjcKhZcbhULLreKJYOlhgWXW8WCy61iweVWseByq1hwuTUsCy63igWXW8WCy61iweVWsWSw1LDgcqtYcLlVLLjcKhZcbhULLreGZcXlVrHgcqtYcLlVLLjcKpYMlhoWXG4VCy63igWXW8WCy61iweXWsBRcbhULLreKBZdbxYLLrWLJYKlhweVWseByq1hwuVUsuNwqFlxuDcuGy61iweVWseByq1hwuVUsGSw1LLjcKhZcbhULLreKBZdbxYLLrWCZBlxuFQsut4oFl1vFgsutYslgqWHB5Vax4HKrWHC5VSy43CoWXG4Ny4jLrWLB5Vax4HKrWHC5VSwZLDUsuNwqFlxuFQsut4oFl1vFgsutYeHdZ3UsuNwqFlxuFQsut4olg6WGBZdbxYLLrWLB5Vax4HKrWHC5NSy8+6yOBZdbxYLLrWLB5VaxZLDUsOByq1hwuVUsuNwqFlxuFQsut4aFd5/VseByq1hwuVUsuNwqlgyWGhZcbhULLreKBZdbxYLLrWLB5daw8O6zOhZcbhULLreKBZdbxZLBUsOCy61iweVWseByq1hwuVUsuNwaFt59VseCy61iweVWseByq1gyWGpYcLlVLLjcKhZcbhULLreKBZdbw8K7z+pYcLlVLLjcKhZcbhVLBksNS0iXm/J+ztMwG2eRh+PgPJTtODqtlYPXef197PrrB++HTtXPLfvHJuPQsqZdjlIeh+YahrHsZ/tBIT8fvCse0sCHVjxkNgmteMjYFVrxkIkysuIxX6EYWvGQPUBoxUNWHKEVD9nehFY8o3gwxencoilO5xZNcTq3aIrTuUVTnM4tmOIxX+gcWnE6t2iK07mpKb4rQzfmpcw87R8755oyGWVElaFrUlWGTkhVGbobL2XKbuRymWrK0LGoKkMXoqlMHugsVJWhW3BSZh72Q+eh1JShA1BVhg5AVZmMMqLK0AGoKoNr9lIm7R87p5oyI65ZVRkcgJMyy7Tt3OZUUyajjKgyOABLmfG4h/xx83F4VmZnSF//c4Y06z9nSAf+c4b47h8zTDjknzOkAf45Q7ranzMkU5kMl8VgmGFoMcxPX/AbawzJKT9nSE75OcOQOWV6YFmtsxiHqezfohqHnJ+aurHWUIzjsq9BYxqXGvOQucaZecgc5Mt8CpmbnJmHzFnOzEPmMmfmIXOcM/MM87czD5kTnZmHzJXOzMmh72dODn0/c3Lo25lncuj7mZND38+cHPp+5uTQ1sxTeuxbMuUa8wzztzMnh76fOTn0/czJoe9nTg59P3Ny6NuZz+TQlzLfaszJoe9nTg5tzjzng/nzc08P5uTQ9zPPMH87c3Lo+5mTQ9/PnBz6fubk0PczJ4e+lPlaYb6QQ9tnovnBvNSY489bM5+WfdeIcVrnGvMM87czx5+/nzn+/P3M8efvZ44/fz9z/Pnbma/48+bMy3EiU6n585X7RO9nzn2i9zMnh76feYb525mTQ9/PnBz6duYx38X82G18GZJxFtOY93OexvLUh6eDYciM05ZhzPcFN2YYMoM0ZhgyUzRmGDIjNGaYYfhjhiE9fGOGIT15Y4Yh7/U0ZkhO+TlDcspPGc4x3xHamCE55ecMySk/Z0hO+TnDDMMfMySn/JwhOeXnDMkpP2dITvk5Q3LKjxnGfCtrY4bklJ8zJKf8nCE55ecMMwx/zJCc8nOG5JSfMySn/JwhOeXnDMkpP2YY8924jRmSU37OkJzyc4bklJ8zzDD8MUNyys8ZklN+zpCc8nOG5JSfMySnWAzTuB88pWmsMIz5LtrGDMkpP2dITvk5Q3LKzxlmGP6YITnl5wzJKSbDaTkYzkONITnl5wzJKT9nSE75McOY7yptzJCc8nOG5JSfMySnmAyX+WC4bjWGGYY/ZkhO+TlDcsrPGZJTfs6QnPJzhuSUHzOM+S7LbzOs3teL+W7KxgzJKT9nGDKnLONxzk/prX4W43AcPA75D4afD855Sr8Pzrl+8cwAfy/wkAnIE3jIuOQJPGS28gQeMoh5Ag+Z2l4IfNt3Is8fdrICPOZrIj2Bh8yDnsBDhkdP4CTNNwPPAH8v8G6SZpoO4Cmn54P3UbvJePao3aQrc9R+Xj6YyvEe9I8O1Dh4O76oOm7lKX7UX8szfFyDjovG+Pxi+4/jd5DduDlvkN24NG+Q3bgvb5AZkG1A9uOWnEH248WcQfbj9JxBdtOPe4Pspvd2BllINo1AkmwagSTZXAE5lwfIdbSOL+t+3mPZHuc9HRVdIQZ5UM9Qd6BOwPKgThrzoE5086BOzvOgTih0oN7PS+5vRZ246UGdbOpBnWzqQT1D3YE62dSDOtnUgzrZ1IM62dSDOtn0/dSXgWzqQZ1s6kGdbOpBnWzqQT1D3YE62dSDOtnUgzrZ1IM62dSDOtnUgfpINvWgTjb1oE429aBONvWgnqHuQJ1s6kGdbOpBnWzqQZ1s6kA94debU0/jsm/Y9PGfuUYdv+5BHb/uQT1D3YE6ft2DOn7dgzp+3YM6ft2DOveSHKhP3EvyoE429aBONvWgTjb1oJ6h7kCdbOpBnWzqQZ1s6kGdbOpBnWzqQD2TTT2ok009qJNNPaiTTT2oZ6g7UCebelAnm3pQJ5t6UCebelAnmzpQn8mmHtTJph7UyaYe1MmmHtRxjheop6eX8aSU/zh+B4kZbANyYc27AnJ9AlmWHx2/g2fZcwLPyucEPgPeBzzdrBN46lkn8PhsJ/D4cifw9LQ+4FeqWifwJFcn8CRXJ/AkVyfwGfA+4EmuTuBJrk7gSa5O4EmuTuBJrj7gC8nVCTzJtTn4lLZjyml8fFPj8d2LQmz1oE5mfQH1dXhQTzXq2Pf21Odp//SP/yw16nh3D+oYdw/quHYH6huW3YM6ft2DOn7dgzp+3YN6hroDde4ueVAnm3pQJ5t6UCclvZ/6OpCSPKiTkjyoZ6g3p17KMeU2DM/UPx885WPIKedUkwibKS8RnlReIgysvETciZGXiECiLtFIepGXiKgjLxF3j+Ql4laTvESYbl+JStpPu6Ra/cPL38UF4i3OzgJtxzeUt22uCUQ7Jy4QlzhfgcZhHB6fPdUkolVQl4g38epLRKsgLxGtgrxEtAryEmUkUpeIVCQvEd9ZkJeI+lReItoFb4nW/aUZ45hqNyF4PbK8RLxLWV8i2gV5iWgX5CWiXZCXKCORukS0C/IS0S7IS0S7IC8R7YK8RLQL6hLxNmx9iWgX5CWiXZCXiHZBXqKMROoS0S7IS0S74CxRSodEz2+Gf5KIdkFeItoFeYloF9QlWmgX5CWiXZCXiHZBXiLaBXmJMhKpS0S7IC8R7YK8RLQL8hLRLshLRLugLtFKuyAvEe2CvES0C/IS0S7IS4Tp9pZofkg0rzWJMN3qEhXsgrdEj89Ov072s0TYBXmJsAvyEmUkUpeImxHyEnEzQl4icpG8ROQieYm4GaEu0cbNCHmJaBfkJaJdkJeIdkFeooxE6hLRLrxTop06hYEHdToAD+rEeg/qJPX3Uy8D4duDOnnagzoR2YM6qdeDeoa6A3WyqQd1sqkHdbKpA/UR59ie+rYsB/W1Sh3n6EGd1fQF1Mv2+/BpGFKNOqupB3VWUw/qNL0e1Gl6Hagnml4P6vh1D+r4dQ/qNL0e1DPUW1M/ZlznGnFy6buJk0nfTZw8+m7iZNF3EyeHvpn4RAZ9N3Hy57uJkz3fTZzc+W7iGeJvJk4CejdxEtC7iZOA3k2cBPRm4pkE1Jz49NhjdErTUqNOCvKgThLyoE4a8qCeoe5AnTtxHtTJog7UZ5zjC6jP5aC+1L5dMeMcPaizmranPo0H9WmqZdOZ1dSDOqupB3XaXQ/qNLwe1Gl5Hagv+HUP6vh1D+o0vR7UaXo9qGeot6de9vOe8lClTjb1oE429aBONvWgTjb1oE42bU89jw/qudav8/53F+pkUw/qZFMP6mRTD+oZ6g7UyaYe1MmmHtTJph7UyaYe1MmmDtQL2dSDOtnUgzrZ1IM62dSDeoa6A3WyqQd1sqkHdbKpB3WyqQd1sqkD9Y1s6kGdbOpBnWzqQZ1s6kEdv+7wlC9vt38F9TIc1LftM/WNN367UMfDeFDHw3hQx8N4UM9Qd6BOv+5BHb/uQR2/7kGdft2DOv26A/WRbPqCZ/DS8QbBaco16mRTD+pkUw/qZFMP6hnqDtTJph7UyaYe1MmmHtTJph7UyaYvoD499v2axwr1RDb1oE429aBONvWgTjb1oJ6h7kCdbPr+vUu3RDb1oE429aBONvWgTjZ1oD6RTT2ok009qJNNPaiTTT2oZ6g7UCebelAnm3pQJ5t6UCebelAnmzpQz2RTD+pkUw/qZFMP6mRTD+oZ6g7UyaYe1MmmHtRJSR7USUkO1GdSkgd1UpIHdVKSB3WcY3PqaVt2JGlbhxp1nKMHde5qeFDHr3tQx687UF/w6x7U8ese1PHrHtS5q+FBPUPdgTrZtH0jMAz7eU8f/7RGnWzqQZ1s6kGdbOpBnWzqQH0lm3pQJ5u+wDmWYy+kYUg16mRTD+pkUw/qGeoO1MmmHtTJph7UyaYe1MmmHtTJpg7UC9nUgzrZ1IM62dSDOtnUg3qGugN1sqkHdbKpB3WyqQd1sqkHdbKpA/WNbOpBnWzqQZ1s6kGdbOpBPUPdgTrZ1IM62dSDOtn07dTH4eN/wN4ceynHlNvwx8MatfOep/2z07xWNcLe62tEGNDXiOigr1FGI3mNiCX6GhFi9DUi8uhrxM07b40e5522ukbc6pPXaKRn0NeInkFfI3oGfY3oGfQ1ymjkrNHjs9Ovk61oRM+grxE9g75G9Az6GtEz6GtEzyCvUaJn0NeInkFfI3oGfY3oGfQ1ymgkrxE9g75G9Az6GtEz6GtEz6CvET2DvEYTPYO+RvQM+hrRM+hrRM+gr1FGI3mNyEe+Gm3bfuy2zVWFSEfqCpGNxBXKJCN1hchF6gqRitQVIhOpK5RRSFwh7ruqK8RdV3WF6BTUFaJTUFeITkFcoZlOQV0hOgXn+w/DODw+e6pqRKugrxG9gr5GGY3kNaJb0NeIdkFfI/oFfY1oGPQ1omOQ12ihZdDXiJ7BW6N0nMqQh6pG9Az6Gv1/7b3dkuQ4FqT3SiQI/j3OSqaLNZOtZNJKZrrQuyvLNMHImgYGqC1kuifOd1djw47m+bwr6O5gAPQM/hplNLLXiJ7BXyN6Bn+N6BmMvHdFI3oG/3xEz2Cv0UnP4K8RPYO/RvQM/hrRM/hrlNHIXiN6Bn+N6Bn8NaJn8NeInsFfI3oGe40uegZ/jegZ/DWiZ/DXiJ7BX6OMRvYa0TP4a0TP4K8RPYO/RvQM/hrRM9hrdNMz+GtEz+CvET2Dv0b0DP4aZTSy14h8pNXoSq/bvtJVVIh0JFYov/Bdx1FUiGzkrdCHRihkrhB+zl2hjELmCrFm5K4QK0buCpGH3BUiD7krRB4yV2glD7krxDqRu0KsErkrRKcgVuh6UN9XUaGMQuYK0Sm4K0Sn4K4QnYK7QnQK7grRKZgrlOgU3BWiU3BXiE7BXSE6BXeFMgqZK0Sn4K4QnYK7QnQK7grRKbgrRKdgrtBGp+CuEJ2Cu0J0Cu4K0Sm4K5RRyFwhOgV3hUis7gqRWN0VIrGaK5RJrO4KkVjdFcoo1KFQvt8K7ddv1z8kccWjSLIiNookOWAUSfz6KJL46kEkd/zvKJL41FEkWQEZRZKVilEkMyQHkSTjjCJJxhlFkowziiQZp4fktr9J5qt1/bFsr8uP9XO3t765k4gk3A/yk4Y7aUvDnWym4U6S03DPcJdwJyVquJMpNdxJoBru5FUNd/KqhPtJXtVwJ69quJNXNdzJqxruGe4S7uRVDXfyqoY7eVXDnbyq4U5elXC/yKvjuefl+fS8/fbrnwc7cVWCnbQ6Hvt2bW/saxE75v0Lvtz39fly31MRO95dgh3rLsGOc5dgx7h/Afb7heRjYeMuYb/x7RLs+HYJdny7BDuLTF+A/b2TyJmKKfXGt4/Hfp3P5de9F7HjZIZj/6gal9eUa9oK2NOCk5Fgx8lIsONkJNhxMhLsGewK7PTtEuz4dgl2+nYJdvp2CXZSqgL7SkqVYCelSrCTUr8A+7E92I9cxE5KlWDPYFdgJ6VKsJNSJdhJqRLspFQJdlKqAnsipUqwk1Il2EmpEuykVAl2fLvgZbyU8O0S7Ph2CXZ8+xe8epqeF62vvdi3b/h2CXZ8uwQ7vl2CHd8uwZ7BrsDO6pIEOylVgp2UKsFOSpVgJ6UqsGdSqgQ7KVXwc+CUSakS7KRUCfYMdgV2UqoEOylVgp2UKsFOSpVgJ6UqsO+kVAl2UqoEOylVgp2UKsGewa7ATkqVYMe3j8e+Py9ar/v1247W/7x4y8+QW86pqBEm316jg0TgrxHxwV8jsoa/RgQTf40yGtlrROTx14hVPH+NWPKz1+jEe2s1utLrtq90FRXCebsrRFenVei+X0TucpvKCdPuCnE6r1ihdXl2hv317ylqRL/gr1FGI3uN6Bf8NaJf8NeIfsFfI7KRv0akI3uNOPP7B2hEl+qvET2DWqPzuXhNxTUJjh7/ARplNLLXiJ7BXyN6Bn+N6Bn8NaJn8NeInsFdo22hZ/DXiJ7BXyN6Bn+N6Bn8NcpoZK8RPYO/RvQM/hrRM/hrRM/grxE9g71GKz2DWKOUnotTykWN6Bn8NaJn8NeInsFfo4xG9hrRM/hrRM/grxE9g79G9Az+GtEz2GuU6Bn8NaJn8NeInsFfI3oGf40yGtlrRM/grxE9g79G9Az2Gm14b7VG+1uj/SxqhPf21wjPoNboTI9Gv262oBGewV8jPIO/RqxN+GvE2oS9Rpm1CX+NyEf+GpGP/DVibcJfo4xG9hrRM3ynRg92qoMvwH5fr8uPtfxfO22ABDsBX4KdzK7AvhPDJdhJ1hLshGUJdvKvBHsGuwI7KVWCnZQqwU5KlWAnpUqwk1LHYz/29cG+FxvIg5QqwU5KlWAnpUqwk1Il2DPYFdhJqRLspFQJdlKqBDspVYKdlKrAfhKXhmNP6/N60scfi7/iPIlLEuzEJQn2DHYFduKSBDtxSYKduCTBTlySYCcuKbBfLOpJsJNSJdhJqRLspFQJ9gx2BXZSqgQ7KVWCnZQqwU5KlWAnpf4l9hfJm+A5iiRZchRJ4uEokiS+USSxtfZb7954YH+NMMz+GuGu3TXKC77dXyMSgb9GZA1/jUgx/hplNBJr9L7vdJc1YkXMXyN6Bn+N6Bn8NaJn8NeInsFeo5WewX0r+LzSM/hrRM/grxE9g79GGY3sNaJn8NeInsFfI3oGf43oGfw1omew1yjRM/hrRM/grxE9g79G9Az+GmU0steInsFfI3oGf43oGfw1omfw14iewV6jjZ7BXyPykVaj+34Rue+9qFBGIXOFyEbuCpGM3BUiF7krRCpyV4hMZK5QJhG5K8S6q7tCrLq6K0Sn4K5QRiFzhegU3BWiU3BXiE5BvP6wrMv7s7eiRrQK/hrRK9hrtNMs+GtEt+CvEe2Cv0b0C/4aZTSy14iOwV8jWgZ/jegZ1Bql51aWvBQ1omfw14iewV6jg57BXyN6Bn+N6Bn8NaJnMPLeFY0yGrnno4OewV8jegZ/jegZ/DWiZ/DXiJ7BXqOTnsFfI3oGf43oGfw1omfw1yijkb1G9Az+GtEz+GtEz+CvET2Dv0b0DPYaXfQM/hrRM/hrRM/grxE9g79GGY3sNaJn8NeInsFfI3oGf43oGfw1omew1+imZ/DXiHyk1ehKr9u+0lVUKKOQVqH8wncdR1EhspG7QiQjd4Xwc94K7Qtuzl0h1ozcFWLFyF0h8pC7QhmFzBUiD7krRB5yV4h1IneFWCVyV4hOQazQ9aC+S932vtIpuCtEp+CuEJ2Cu0J0Cu4KZRQyV4hOwV0hOgV3hegU3BWiU3BXiE7BXKFEp+CuEJ2Cu0J0Cu4K0Sm4K5RRyFwhOgV3hegU3BWiU3BXiE7BXSE6BXOFNjoFd4XoFNwVIrG6K5RRyFwhEqu7QiRWd4VIrOYKZevVh+N19X5tWwP6sb4uXo9PZzl+XPzMau2KBs+aA81q/aQePKt1w/QHs6b1fn1JpnS27mN5vn5TSs1vyGVd0/ONuu7pt+sfktZN0E8iuVs3Nj+KpHWz8qNIzuJr9CRncU16khmSg0jO4vj0JK07lB9F0rrr+FEkyTijSJJxBpE8yDg9JPfrTfJcW9df51N8XvdeqicPApEEO+lJgp2oJcGewa7AToiTYCfxSbATDyXYyZIS7ARPBfaTlCrBTkqVYCelSrCTUiXYM9gV2EmpEuykVAl2UqoEOylVgp2UqsB+kVIl2EmpEuykVAl2UqoEewa7AjspVYKdlCrBTkqVYCelSrCTUhXYb1KqBDspVYKdlCrBTkqVYM9gV2AnpUqwk1Il2PHtw7Gn9dn86uOPuYD9WPDtEuz4dgl2fLsEO75dgj2DXYEd3y7Bjm+XYGd1SYKd1SUJdlKqAvtKSpVgJ6VKsJNSJdhJqRLsGewK7KRUCXZSqgQ7KVWCnZQqwU5KVWBPpFQJdlKqBDspVYKdlCrBnsGuwE5KlWAnpUqwk1Il2EmpEuykVAX2jZQqwU5KlWDHQHZgT5/O9Ekp/3b9QxJPOIokD74ekucnktfxV9e/yGeefSryPP5U5OlpVeSpalXkM+RF5PHbKvL4cxV5alsVeZpbFXkyrIj8ToZVkSfDqsiTYVXkybAq8hnyIvJkWBV5MqyKPBlWRZ4MqyJPhh1OPqX7mXJb3y9wfHol4yDASrCTXr8A+7m8saci9gz24dj37bmVfbuK2PHwEuwYeAl23LsEO9Zdgh3frsB+4tsl2PHtEuwsOUmws94kwZ7BrsBOSpVgJy5JsBOXJNiJSwrsFwZyPPbreqa8l+Uz9n9evOWH9ZZzsZy/cJv+GmU0stcIH+uvEUsz/hoRTPw1IsX4a0TksdfoZjnJXyPWnvw1wntrNbrS606uVGyCOFHeXKGTc6HFCt3P68v3vRcVoqlzV4hvOa1C67Iu78/eihrRL/hrRL/grxH9gr1GnBn8AzSiX/DXiGzkrxHpyF+jjEb2GtGl+mtEz6DW6HydurGuKRU1omfw14iewV8jegZ7jTj1+QdoRM/grxE9g79G9Az+GmU0steInsFfI3oGf43oGfw1omfw14iewV4jzu3+ARrRM/hrRM/grxE9g79GGY20GqX0aPT5qPnPGtEz+GtEz+CvET2Dv0b0DP4a0TPYa5TpGfw1omfw14iewV8jegZ/jTIa2WtEz+CvET2Dv0b0DP4a0TP4a0TPYK/RTs/grxE9g79GeG+1Rvtbo/0saoT39tcIz6DW6P3Z6dfN/lOjA8/grxGewV8j1ib8NWJtwl+jjEb2GpGP/DUiH/lrxNqEv0asTfhrRM9gr9FJz+CvET2Dv0b0DP4a0TN8p0YP9gx2BXbaAAl2Ar4EO5ldgp0YLsFOslZgvwjLEuzkXwl2Iq0EOylVgj2DXYGdlCrBjoEcj/0+jgf7WcR+YyAl2HmkfgH26/7X5duyFPfNu3mkSrDzSJVgp/iVYKf4lWCn+JVgx7cLsF8Lvl2CneJXgp3idzj2Z8ZzLyInoX478gzy70ZOMv125KTSb0dOIv125KTRb0dOEv1u5Csp9NuRk0C/HTnp89uRZ5B/N3Ki0LcjJwp9O3Ki0LcjJwoNR7699ybd0nYUsROHFNgTkUiCnVgkwU40kmBncU6CPYNdgR0D+QXY9+vBfhRfukgYSAX2jUfqeOzb+mDftmJK3XikSrDzSJVgp+yVYKfwlWCn9JVgx7dLsOPbFdgzxa8EO8WvBDsp9QuwXy98W17K2EmpEuwZ7ArspFQJdlKqBDspdTz2vL6x52LfzpnyGuykVAV2Tn7XYCelSrCTUiXYSakS7BnsCuykVAl2UqoEOylVgp2UKsFOSlVgP0ipEuykVAl2UqoEOylVgj2DXYGdlCrBTkqVYCelSrCTUiXYSakK7CcpVYKdlCrBnsEu+DnwiW//AuzX8mC/7yJ2nIwEO05GgZ1jxDXYcTIS7PTtEuz07RLsGewK7Ph2CXb6dgl2+nYJdlLqF/xSLz3HEW5bLmInpSqw36RUCXZSqgQ7KVWCnZQqwZ7BrsBOSpVgJ6VKsJNSvwD79t4rbF+L2EmpEuykVAH2eyGlSrCTUiXYSakS7KRUwa6n95LBrsBOSpVgJ6VKsJNSJdhJqRLspFQF9pWUKsFOSpVgJ6VKsJNSJdgz2BXYSakS7KRUCXZSqgQ7KVWCnZSqwJ5IqRLspFQJdlKqBDspVYI9g12BnbgkwU5ckmAnLkmwE5cU2DfikgQ7BnI49nQfLyTpPpci9gx2BXaWOSTY8e0S7Ph2CXZ8uwQ7vl2BPePbJdhZ5pBgZ5lDgp2UOr4cWJZn2/yPf7SIPYNdgZ2UKsFOSpVgJ6VKsJNSJdhJqV9gIK9n96RlKZ1Ec++kVAl2UqoEOylVgp2UKsGewa7ATkqVYCelSrCTUiXYSakS7KRUBfaDlCrBTkqVYCelSrCTUiXYM9gV2EmpEuykVAl2UqoEOylVgp2UqsB+klIl2EmpEuykVAl2UqoEewa7AjspVYId3z4e+3U9U97Lb7/mKHx42rfXZ6e9+MLkicm31+giEfhrRHzw14is4a8RwcRfo4xG9hoRefw1YhVPrdFzK2u6yxqx5OevET2Dv0b0DPYa3fQM/hrRM/hrRM+g1uj92enXzRY0omfw1yijkb1G9Az+GtEz+GtEz+CvET2Dv0b0DOYarctCz+CvET2Dv0b0DP4a0TP4a5TRyF4jegZ/jegZ/DWiZ/DXiJ7BXyN6BnuNVnoGf43oGfw1omfw14h8pNXovl/XfqyJFxUiHbkrRDZyV4hk5K4QuchcoUQqcleITOSuEInIXSHWXd0VyihkrhCdgrtCdAruCtEpuCtEp+CuEJ2CeP3hYyn1/dlbSaONVsFfI3oFf41oFvw1olvw1yijkb1G9Av+GtEw+GtEx+CvES2Dv0b0DGqN0vl8dl5KGmV6Bn+N6Bn8NaJn8NeInsFfo4xG9hrRMxh574pG9Az2+SjTM/hrRM/grxE9g71GOz2Dv0b0DP4a0TP4a0TP4K9RRiN7jegZ/DWiZ/DXiJ7BXyN6Bn+N6BnsNTroGfw1omfw14iewV8jegZ/jTIa2WtEz+CvET2Dv0b0DP4a0TP4a0TPYK/RSc/grxE9g79G9Az+GpGPtBpd6XUn16cb+awQ6UisUH7hu46jqBDZyF0hkpG5Qhd+zl0h3Jy7QqwZuSuUUchcIfKQu0LkIXeFyEPuCpGH3BVinchcoZtVIneF6BTECl0P6rvYbd90Cu4K0Sm4K5RRyFwhOgV3hegU3BWiU3BXiE7BXSE6BW+F1oVOwV0hOgV3hegU3BWiU3BXKKOQuUJ0Cu4K0Sm4K0Sn4K4QnYK7QnQK5gqtdAruCtEpuCtEp+CuEJ2Cu0IkVneFSKzuCpFY3RUisborRGI1VyjhtnsUyvdbof336x+SuOJRJDMkB5EkB4wiiV8fRRJfPYok/ncUSXzqIJIbKyCjSLJSMYokGWcUSTLOKJIZkoNIknFGkSTj9JDc9jfJ3Lz+WLbX5cf6udtb39xJRBru5CcNd9KWhHsmm2m4k+Q03Ml9Gu6kRA33DHcJdxKohjt5VcOdvKrhTl7VcCevSrjv5FUNd/Kqhjt5VcOdvKrhnuEu4U5e1XAnr2q4k1c13Mmr47nn5XUrHz37b7/+ebATVxXYD9LqeOzbtb2xr0XsmPcv+HLf1+fLfU9F7BnsCuxYdwl2nLsEO8b9C7DfLyTrud5F7Ph2CXZ8uwL7iW+XYGeR6Quwv3cSOVMxpZ4Z7MOxX+dz+XXvRew4meHYP6rG5fXpa9qK2HEyEuw4GQX2CycjwY6TkWDnbRkJdvp2CfYMdgV2+nYJdvp2CXZSqgQ7KVWCnZSqwH6TUr8A+7E92I9cxE5KlWAnpUqwk1Il2DPYFdhJqRLspFQJdlKqBDspVYKdlCrAnhZSqgQ7KVWCPYP9+1/GSwu+XYId3y7Bjm//gldP0/Oi9bVvRez4dgl2fLsC+4pvl2DHt0uws7okwc7qkgR7BrsCOylVgp2UKsFOSpVgJ6VKsJNSBT8HTomUKsFOSpVgJ6VKsJNSJdgz2BXYSakS7KRUCXZSqgQ7KVWCnZSqwL6RUiXYSakS7KRUCXZSqgQ7vn089v150Xrdr992tP7nxVt+WG85p6JGmHx/jUgE/hoRH+w1ymQNf40IJv4akWL8NSLy+GuU0cheI5b8/DXCe2s1utLrTq5PN/JJoR3n7a4QXZ1Woft+zXiX21ROmHZXiNN5xQqty7Mz7K9/T1Ej+gV/jegX/DWiX/DXKKORvUb0C/4akY38NSId+WvEewz+GtGl2mvEaeJyjc7n4jUV1yQ4evwHaETP4K8RPYO/RhmN7DWiZ/DXiJ7BXyN6Bn+N6Bn8NaJnsNfoomfw14iewV8jegZ/jegZ/DXKaGSvET2Dv0b0DP4a0TP4a0TPINYopefilHJRI3oGe41uegZ/jegZ/DWiZ/DXiJ7BX6OMRvYa0TP4a0TP4K8RPYO/RvQM/hrRM7hrtC30DP4a0TP4a0TP4K8RPYO/RhmN7DWiZ/DXCO+t1mh/a7SfJY1WvLe/RngGtUZnejT6dbMFjTIa2WuEZ/DXiLUJf41Ym/DXiLUJf43IR/YaJfKRv0asTfhrxNqEv0b0DN+p0YM9g3089vt6XX6s5f/aaQMk2An4Euxkdgl2YrgEO8lagX0jLEuwk38l2Im0EuykVAn2DHYFdlKqBDspVYKdlDoe+7GvD/a92EBupFQJdlKqAnsmpUqwk1Il2EmpEuykVAn2DHYFdlKqBDspVYKdlCrBTlwajj2tz+tJH38s/opzJy5JsBOXJNiJSxLsxCUJ9gx2BXbikgQ7cUmCnbgkwc6ingQ7KVWB/SClSrCTUiXYSakS7KRUCfYMdgV2UqoEOylVgp2U+pfYH5IEz1EkyZKDSJ7Ew1EkSXyjSGZIum+9e+KB/TXCMPtrhLv21wjf7q8RicBeo4us4a8RKcZfIxa51Bo9t/LrQNqiRqyI+WuU0cheI3oGf43oGfw1omfw14iewX4r+IuewV6jm57BXyN6Bn+N6Bn8NaJn8Ncoo5G9RvQM/hrRM/hrRM/grxE9g79G9AzuGuWFnsFfI3oGf43oGfw1omfw1yijkb1G9Az+GtEz+GtEz+CvET2DvUYr+Uir0X2/ZrzvvagQ6chdIbKRu0IZhcwVIhe5K0QqcleITOSuEInIXSHWXc0VSqy6uitEp+CuEJ2Cu0J0Cu4KZRQyV4hOQbz+sKzL+7O3oka0Cv4a0Sv4a0Sz4K8R3YK9Rhvtgr9G9Av+GtEw+GtEx+CvUUYje43oGdQapfP57LwUNaJn8NeInsFfI3oGf43oGew1yvQM/hrRMxh574pG9Az2+SjTM/hrlNHIXiN6Bn+N6Bn8NaJn8NeInsFfI3oGe412egZ/jegZ/DWiZ/DXiJ7BX6OMRvYa0TP4a0TP4K8RPYO/RvQM/hrRM9hrdNAz+GtEz+CvET2Dv0b0DP4aZTSy14iewV8jegZ/jegZ/DWiZ7DX6CQfaTW60utOrk838lkh0pFYofzCdx1HUSGykbtCGYXMFcLPuSuEm3NXiDUjc4UuVozcFSIPuStEHnJXiDzkrlBGIXOFWCdyV4hVIneF6BTECl0P6rvYbV90Cu4K0SmYK3TTKbgrRKfgrhCdgrtCdAruCmUUMleITsFdIToFd4XoFNwVolNwV4hOwVuhfaFTcFeITsFdIToFd4XoFNwVyihkrhCdgrtCdAruCtEpuCtEp+CuEJ2CuUIridVdIRKru0IkVneFMgqZK0RidVdoFre9HvsL+vrxb/l88TPrLL61Y9Y0i79Yr+v5z/3Od+Pie30OXb2vu/k3b13T8zfvg9lv1z8kZ/EBepKzPK/1JGd5rupJztLY6knO0qzqSU7jyeQkp3F8apLbLG8p6UnO0s3qSZJxRpEk44wimSHZQXK/3iQ/FRiV66/zKciuey/VWBuBSIKd9CTBTtSSYCeXSbAT4hTYM4lPgp14KMFOlpRgJ3hKsGewK7CTUiXYSakS7KRUCXZSqgQ7KVWBfSelSrCTUiXYSakS7KRUCfYMdgV2UqoEOylVgp2UKsFOSpVgJ6UqsB+kVAl2UqoEOylVgp2UKsGewa7ATkqVYCelSrCTUiXYSakS7KRUBfaTlCrBjm8fjj2tzyZJH3/MRewZ7Ars+HYJdny7BDu+XYId3y7Bjm9XYL/w7RLsrC5JsLO6JMFOSpVgz2BXYCelSrCTUiXYSakS7KRUCXZSqgL7TUqVYCelSrCTUiXYSakS7BnsCuykVAl2UqoEOylVgp2UKsFOShVgPxZSqgQ7KVWCnZQqwU5KlWDPYFdgJ6VKsGMgO7CnT2f6pJR/u/5FcsUTjiLJg6+H5PmJ5HX81fUPeZ59KvI8/lTk6WlV5KlqVeRpa1Xk8dsi8gl/riJPbasiT3OrIk+GVZHPkBeRJ8OqyJNhVeTJsCryZFgVeTKsiPxGhlWRJ8OqyJNhVeTJsMPJp3Q/U27r+wWOT69kbBnsCuyk1y/Afi5v7KmIHRs/Hvu+vT79449XETseXoE9Y+Al2HHvEuxYdwl2fLsEewa7Aju+XYKdJScJdtabJNhJqRLspFQF9p24JMFOXJJgJy5JsGMgx2O/rmfKe1k+Y//nxVt+WG85F8v5HbfprxHW1F8jfKy9RgdLM/4aEUz8NSLF+GtE5PHXKKORvUasPflrhPfWanSl/EKdik0QJ8rbK0RXp1Xofl5fvu+9qBBNnblCnL8rVmhd1uX92VtRI/oFf43oF/w1ol/w1yijkb1G9Av+GpGN/DUiHflrxHsM/hrRpdprxAnKco3O577XVFyT4LjlH6ARPYO/RvQM/hplNLLXiJ7BXyN6Bn+N6Bn8NaJn8NeInsFdo5MzsH+ARvQM/hrRM/hrRM/gr1FGI3uN6Bn8NaJn8NeInsFfI3oGsUYpPff9+aj5zxrRM9hrtNIz+GtEz+CvET2Dv0b0DP4aZTSy14iewV8jegZ/jegZ/DWiZ/DXiJ7BXqNEz+CvET2Dv0b0DP4a0TP4a5TRyF4jegZ/jfDeao32t0b7WdJow3v7a4RnUGv0/uz062YLGmU0stcIz+CvEWsT/hqxNuGvEWsT/hqRj+w1yuQjf41Ym/DXiLUJf43oGfw1ymhkrxE9g79G9Az+GtEzfKdGD3aqAwl22gAF9p2AL8FOZpdgJ4ZLsJOsJdgz2BXYyb8S7ERaCXZSqgQ7KVWCnZSqwH5gIMdjv4/jwX6WsWewK7DzSP0C7Nf9r8u3ZSnum3fwSJVg55GqwH5S/EqwU/xKsFP8SrDj2yXYM9gV2Cl+Jdgpfodjf2Y89yJyEuq3Iyedfjtykul3I79Ipd+OnET67chJo9+OnCT67cgzyL8bOQn025GTPr8dOVHo25EThb4b+U0U+nbkRKFvR04UGo58e+9NuqXtKGInDkmwZ7ArsBOLJNiJRhLsLM5JsJNKBdivBQP5Bdj368F+pCJ2DKQEO4/U8di39cG+bXsRO49UCXYeqRLslL0K7CuFrwQ7pa8EO75dgh3fLsGewa7ATvErwU5K/QLs1wvflpcydlKqBDspVYKdlKrAzmn1Guyk1PHY8/rGnot9O2fKa7CTUiXYM9gV2EmpEuykVAl2UqoEOylVgp2UqsC+kVIl2EmpEuykVAl2UqoEewa7AjspVYKdlCrBTkqVYCelSrCTUhXYMylVgp2UKsFOSpVgJ6VKsGewK7CTUiXYp0mp9/HCnpZtadzHcuXXxSldTezr+sa+7um36x+S0wRPOclpsqSc5DTxUE1ynybxyUlOE+LkJKfJZXKS00QtOckMyUEkpwlEcpJknFEkyTijSJJxekg++2p9/PlcW9df5wvfet3FX2PtBCIF9oP0JMFO1JJgJ5dJsBPiJNgz2BXYiYcS7GRJCXaCpwQ7KVWCnZSqwH6SUiXYSakS7KRUCXZSqgR7BrsCOylVgp2UKsFOSpVgJ6VKsJNSFdgvUqoEOylVgp2UKsFOSpVgz2BXYCelSrCTUiXYSakS7KRUCXZSqgL7TUqVYCelSrCTUiXY8e3Dsaf1fSvrkYvY8e0S7Ph2CXZ8uwQ7vl2A/V7w7RLs+HYJdny7BDurSxLsGewK7KRUCXZSqgQ7KVWCnZQqwU5KVWBfSakS7KRUCXZSqgQ7KVWCPYNdgZ2UKsFOSpVgJ6VKsJNSJdhJqQrsiZQqwU5KlWAnpUqwk1Il2DPYFdhJqRLspFQJdlKqAvuGgezAnj6dcpJS/u36hySecBRJHnw9JP/oeNz/fP1DnmefijyPPxV5eloVeapaEflMW6sij99Wkcefq8hT26rIZ8iLyJNhVeTJsCryZFgVeTKsijwZVkR+J8OqyJNhVeTJsCryZFgV+Qx5EXky7HDyKd3PlNv6foHj0ysZOwFWgp30+gXYz+WNPZWwH9j48dj37Xx9+r5dRex4eAl2DLwEO+5dgj2DXYEd3y7Bjm+XYMe3S7Cz5CTBznqTAvtJSpVgJ6VKsBOXJNgz2BXYiUsS7BjI8div65nyXpbP2P958ZYf1lvOxXL+xG3aa3RhTf01wsf6a8TSjL9GBBN/jTIa2WtE5PHXiOUkf41Ye7LXiGPixRpd6XUnVyo2QZwob68QXZ1Woft5ffm+96JCNHXWCqWF83fFCq3Lurw/eytqRL/gr1FGI3uN6Bf8NaJf8NeIfsFfI7KRv0akI3uNOOf4B2hEl+qvET2DWqPzdd/rmlJRI3oGf40yGtlrRM/grxE9g79G9Az+GtEz+GtEz2CvESdV/wCN6Bn8NaJn8NeInsFfo4xG9hrRM/hrRM/grxE9g79G9Az+GtEz2Gu00TOINUrp0ejzUfOfNaJn8NeInsFfI3oGf40yGtlrRM/grxE9g79G9Az+GtEz+GtEz2CvUaZn8NeInsFfI3oGf43oGfw1ymhkrxE9g79G9Az+GtEz2Gu0473VGu1vjfazqBHe218jPINao/dnp183W9AIz+CvEZ7BXyPWJvw1Ym3CXqODtQl/jchH/hqRj/w1Ym3CX6OMRvYa0TP4a0TP4K8RPYO/RvQM/hrRM3ynRi/sJ9WBBDttgAQ7AV+CncwuwZ7BrsBOspZgJyxLsJN/JdiJtBLspFQF9ouUKsFOSpVgx0COx34fx4P9LGPHQEqw80j9AuzX/a/Lt2Up7pt380iVYOeRKsFO8SvBTvErwZ7BrsCOb5dgx7dLsFP8SrBT/A7H/sx47kXkJNRvRr4upNNvR04y/XbkpNJvR04i/XbkGeTfjZwk+u3ISaHfjpwE+u3ISZ/fjXwlCn07cqLQtyMnCn07cqLQtyPPIB+NfHvvTbql7ShiJw5JsBOJJNiJRRLsRCMJdhbnFNgTqVSCPYN9PPb9erAfqYgdAynBziN1PPZtfbBvWzGlJh6pCuwbj1QJdspeCXYKXwl2Sl8J9gx2BXZ8uwQ7xa8EO8WvBDsp9QuwXy98W17K2EmpCuyZlCrBTkqVYCelSrCTUsdjz+sbey727Zwpr8FOSpVgJ6VKsJNSJdhJqRLspFQF9p2UKsFOSpVgJ6VKsJNSJdgz2BXYSakS7KRUCXZSqgQ7KVWCnZSqwH6QUiXYSakS7KRUCXZSqgR7BrsCOylVgp2UKsFOSlVgP/Htip8Dn/j2L8B+LQ/2+y5iz2BXYMfJSLDjZCTYcTIS7PTtEuz07QrsHCOuwY5vl2Cnb5dgp2+XYM9gH/9LvfQcR7htuYidlCrBTkqVYCelSrCTUiXYSakK7DcpVYKdlCrBTkqVYCelfgH27b1X2L4WsWewK7CTUiXYSakS7KRUCXZSqgQ7KVWw62laSKkS7KRUCXZSqgQ7KVWCPYNdgZ2UKsFOSpVgJ6VKsJNSJdhJqQrsKylVgp2UKsFOSpVgJ6VKsGewK7CTUiXYSakS7KRUCXZSqgQ7KVWBPZFSJdiJSxLsxCUJ9gx2BXbikgQ7cUmCHQM5HHu6jxeSdJ9LCfuGgZRgZ5lDgh3fLsGOb5dgz2BXYMe3S7Dj2yXYWeaQYGeZQ4KdlDq+HFiWZ9v8j3+0hD2TUiXYSakS7KRUCXZSqgR7BrsCOyn1Cwzk9eyetCypiJ2UKsFOSpVgJ6VKsJNSFdh3UqoEOylVgp2UKsFOSpVgz2BXYCelSrCTUiXYSakS7KRUCXZSqgL7QUqVYCelSrCTUiXYSakS7BnsCuykVAl2UqoEOylVgp2UKsFOSlVgP0mpEuykVAn2DPbh2K/rmfJefvs1R+HDP9ZVX5/9UcMXNcLk+2tEIvDXiPjgrxFZw18jgom9Rhcpxl8jIo+/RqziqTV6bmVNd1kjlvz8NcpoZK8RPYO/RvQM/hrRM/hrRM+g1uj92enXzRY0omew1+imZ/DXiJ7BXyN6Bn+N6Bn8NcpoZK8RPYO/RvQM/hrRM/hrRM/grxE9g7tG20LP4K8RPYO/RvQM/hrRM/hrlNHIXiN6Bn+N6Bn8NaJn8NeInsFeo5V8pNXovl/X3vdeVIh05K4Q2chdoYxC5gqRi9wVIhW5K0QmcleIROSuEOuu5golVl3dFaJTcFeITsFdIToFd4UyCpkrRKcgXn9Y1uX92VtRI1oFf43oFfw1olnw14huwV6jjXbBXyP6BX+NaBj8NaJj8Ncoo5G9RvQMao3S+Xx2Xooa0TP4a0TP4K8RPYO/RvQM9hplegZ/jegZjLx3RSN6Bvt8lOkZ/DXKaGSvET2Dv0b0DP4a0TP4a0TP4K8RPYO9Rjs9g79G9Az+GtEz+GtEz+CvUUYje43oGfw1omfw14iewV8jegZ/jegZ7DU66Bn8NaJn8NeInsFfI3oGf40yGtlrRM/grxE9g79G9Az+GtEz2Gt0ko+0Gl3pdSfXpxv5rBDpSKxQfuG7jqOoENnIXaGMQuYK4efcFcLNuSvEmpG5QhcrRu4KkYfcFSIPuStEHnJXKKOQuUKsE7krxCqRu0J0CmKFrgf1Xey2LzoFd4XoFMwVuukU3BWiU3BXiE7BXSE6BXeFMgqZK0Sn4K4QnYK7QnQK7grRKbgrRKfgrVBe6BTcFaJTcFeITsFdIToFd4UyCpkrRKfgrhCdgrtCdAruCtEpuCtEp2Cu0EpidVeIxOquEInVXaGMQuYKkVjdFcJt9yiU77dC++/XPyRxxYNIJlbERpEkB4wiiV8fRRJfPYpkhuQgkvjUUSRZARlFkpWKUSTJOKNIknEGkdzIOKNIknFGkSTj9JDc9jfJ3Lz+WF63sh7r525vfXMnEWm4Z7hLuJO2NNzJZhruJDkNd3KfhjspUcI9kyk13EmgGu7kVQ138qqGe4a7hDt5VcOdvKrhTl7VcCevariTVyXcd/Kqhjt5VcOdvKrhTl7VcM9wH849L+fr8rz99uufBztxVYKdtDoe+3Ztb+xrETvm/Qu+3Pf1+XLfUwn7gXeXYMe6S7Dj3CXYMe5fgP1+IVnP9S5iz2BXYMe3S7Dj2yXYWWT6AuzvnUTOVEypJ759PPbrfC6/7r2IHSczHPtH1bi8Pn1NWxF7BrsCO05Ggh0nI8GOk5Fg520ZCXb6dgX2C98uwU7fLsFO3y7BTkqVYM9gV2AnpUqwk1K/APv7VtYjF7GTUiXYSakS7KRUBfablCrBTkqVYCelSrCTUiXYM9gV2EmpEuykVAl2UqoA+77g2wUv4+0Lvl2CHd8uwY5v/4JXT9PzovW1b0XsGewK7Ph2CXZ8uwQ7vl2CndUlCXZWlxTYV1KqBDspVYKdlCrBTkqVYM9gV2AnpQp+DryvpFQJdlKqBDspVYKdlKrAnkipEuykVAl2UqoEOylVgj2DXYGdlCrBTkqVYCelSrCTUiXYSakK7Bu+fTz2/bmVdb9+29H6nxdv+WG95ZyKGmHy/TXKaGSvEfHBXyOyhr9GBBN/jUgx/hoReew1yqzi+WvEkp+/RnhvrUZXet3J9elGPiuE8zZXiHOjxQrd92vGu9ymcsK0vUJ8y2kVWpdnZ9hf/56iRvQL/hrRL/hrRL9grxHnZ/8AjegX/DUiG/lrRDry1yijkb1GdKn+GtEzqDU6n4vXVFyT4OjxH6ARPYO/RvQM9hqd9Az+GtEz+GtEz+CvET2Dv0YZjew1omfw14iewV8jegZ/jegZ/DWiZ7DX6KJn8NeInsFfI3oGf43oGfw1ymik1Sil5+KUiqdOXvQM/hrRM/hrRM/grxE9g79G9Az2Gt30DP4a0TP4a0TP4K8RPYO/RhmN7DWiZ/DXiJ7BXyN6Bn+N6Bn8NaJncNfoWOgZ/DWiZ/DXCO+t1mh/a7SfRY3w3v4a4RnUGp3p0ejXzf5ToxXP4K8RnsFfI9Ym/DVibcJfo4xG9hqRj/w1Ih/5a8TahL9GrE34a0TP8J0avbAnqoMvwH5fr8s/cn8RO22ABDsBX4KdzC7BnsGuwE6ylmAnLEuwk38l2Im0EuykVAX2jZQqwU5KlWAnpUqwk1LHYz/29cG+FxvILYNdgZ2UKsFOSpVgJ6VKsJNSJdhJqQrsmZQqwU5KlWAnpUqwk1Il2IlLw7Gn9X0r61H8FWcmLkmwE5ck2IlLEuzEJQX2nbgkwU5ckmAnLkmwE5ck2DPYFdhJqRLspFQJdlKqBDspVYKdlKrAfpBSJdhJqRLspFQJdlLqX2J/SGZIDiJJlhxFkng4iiSJbxDJE1trv/XuiQf21wjD7K8R7tpfo4xG9hqRCPw1Imv4a0SK8deIRS61Rs+trOkua8SKmL1GFz2Dv0b0DP4a0TP4a0TP4K9RRiOxRs2t4C96Bn+N6Bn8NaJn8NeInsFfI3oGe41uegZ/jegZ/DWiZ/DXiJ7BX6OMRvYa0TP4a0TP4K8RPYO/RvQM/hrRM7hrdC70DP4a0TP4a0TP4K8RPYO/RhmN7DUiH2k1uu/XjPe9FxUiHbkrRDYyV2glGbkrRC5yV4hU5K4QmchdoYxC5gqx7uquEKuu7grRKbgrRKfgrhCdgrlCiU7BXSE6BfH6w7Iu78/eihrRKvhrRK/gr1FGI3uN6Bb8NaJd8NeIfsFfIxoGf43oGOw12mgZ/DWiZ1BrlM7ns/NS1IiewV8jegZ/jTIa2WtEz+CvET2Dv0b0DEbeu6IRPYN/PqJnsNco0zP4a0TP4K8RPYO/RvQM/hplNLLXiJ7BXyN6Bn+N6Bn8NaJn8NeInsFeo52ewV8jegZ/jegZ/DWiZ/DXKKORvUb0DP4a0TP4a0TP4K8RPYO/RvQM9hod9Az+GtEz+GtEz+CvET2Dv0YZjew1Ih9pNbrS606uTzfyWSHSkVih/MJ3HUdRIbKRuUInychdIfycu0IZhcwVYs3IXSFWjNwVIg+5K0QecleIPGSu0EUecleIdSJ3hVglcleITkGs0PWgvovd9pVRyFwhOgV3hegU3BWiU3BXiE7BXSE6BXOFbjoFd4XoFNwVolNwV4hOwV2hjELmCtEpuCtEp+CuEJ2Cu0J0Cu4K0Sl4K3QtdAruCtEpuCtEp+CuEJ2Cu0IZhcwVolNwV4jE6q4QidVdIRKruUIridVdIRKru0J5FoWu68Fy57sl5/ocznlfd1uhM70Vuo7G9Vvar39dvqUjFbFPY6GdsF/Lg/2+i9incV0/C/s0VupHYU/T+KOfhX0a0/OzsE/Tvf8s7NMU6j8Lewa7Aju+XYJ9mnfkfhb2aZYRfhZ2Uup47B+wX9i3LRexk1IV2DdSqgQ7KVWCnZQqwU5KlWDPYFdgJ6VKsJNSJdhJqV+AfXuWsLd9LWInpUqwk1IV2DMpVYKdlCrBTkqVYCelfgH29Y1924vYM9gV2EmpEuykVAl2UqoEOylVgp2UqsC+k1Il2EmpEuykVAl2UqoEewa7AjspVYKdlCrBTkqVYCelSrCTUhXYD1KqBDspVYKdlCrBTkqVYM9gV2AnLkmwE5ck2IlLEuzEJQX2k7gkwY6BHI493ccLSbrPpYg9g12BnWUOCXZ8uwQ7vl2CHd8uwY5vV2C/8O0S7CxzSLCzzCHBTkodXw4sywvf9vGPFrFnsCuwk1Il2EmpEuykVAl2UqoEOyn1Cwzk9eyetCzFk2huUqoEOylVgp2UKsFOSpVgz2BXYCelSrCTUiXYSakS7KRUCXZSqgD7vZBSJdhJqRLspFQJdlKqBHsGuwI7KVWCnZQqwU5KlWAnpUqwk1IV2FdSqgQ7KVWCnZQqwU5KlWDPYFdgJ6VKsOPbx2O/rmfKjwWNz9gLH572577TfhY1wuTba5RIBP4aER/8NSJr+GtEMPHXKKORvUZEHn+NWMVTa3TlR6O7rBFLfv4a0TP4a0TPYK/RRs/grxE9g79G9Axqjd6fnX7dbEEjegZ/jTIa2WtEz+CvET2Dv0b0DP4a0TP4a0TPYK9Rpmfw14iewV8jegZ/jegZ/DXKaGSvET2Dv0b0DP4a0TP4a0TP4K8RPYO9Rjs9g79G9Az+GtEz+GtEPtJqdN+va+97LypEOnJXiGzkrhDJyF0hcpG5QgepyF0hMpG7QiQid4VYd3VXKKOQuUJ0Cu4K0Sm4K0Sn4K4QnYK7QnQK4vWHZV3en72VNDppFfw1olfw14hmwV8jugV/jTIa2WtEv+CvEQ2Dv0Z0DP4a0TL4a0TPoNYoPbey5KWk0UXP4K8RPYO/RvQM/hrRM/hrlNHIXiN6BiPvXdGInsE+H130DP4a0TP4a0TPYK/RTc/grxE9g79G9Az+GtEz+GuU0cheI3oGf43oGfw1omfw14iewV8jegZzjbZloWfw14iewV8jegZ/jegZ/DXKaGSvET2Dv0b0DP4a0TP4a0TP4K8RPYO9Ris9g79G9Az+GtEz+GtEPtJqdKX8Qp2uokKkI7FC+YXvOo6iQmQjd4VIRuYKJfycu0K4OXeFWDNyVyijkLlC5CF3hchD7gqRh9wVIg+5K8Q6kblCG6tE7grRKYgVuh7Ud7Hb3ugU3BWiU3BXKKOQuUJ0Cu4K0Sm4K0Sn4K4QnYK7QnQK5gplOgV3hegU3BWiU3BXiE7BXaGMQuYK0Sm4K0Sn4K4QnYK7QnQK7grRKZgrtNMpuCtEp+CuEJ2Cu0J0Cu4KkVjdFSKxuitEYnVXiMTqrhCJ1VyhA7fdo1C+3wrt12/XPyRxxaNIZkgOIkkOGEUSvz6KJL56FEn87yiS+NRBJE9WQEaRZKViFEkyziiSZJxRJDMkB5Ek44wiScbpIbntb5L5al1/LM+tHOvnbm99cycRabiTnzTcSVsS7hfZTMOdJKfhTu7TcCclarhnuEu4k0A13MmrGu7kVQ138qqGO3lVwv0mr2q4k1c13MmrGu7kVQ33DHcJd/Kqhjt5VcOdvKrhTl4dzz0vz6fn7bdf/zzYiasC7OtCWh2PfXvfSt7WInbM+xd8ue/r8+W+pyL2DHYFdqy7BDvOXYId4/4F2O8XkvVc7yJ2fLsEO75dgX3Ft0uws8j0BdjfO4mcqZhS1wz24div87n8uvcidpzMcOwfVePymnJNWxE7TkaCHSejwJ5wMhLsOBkJdt6WkWCnb5dgz2BXYKdvl2Cnb5dgJ6VKsJNSJdhJqQrsGyn1C7Af24P9yEXspFQJdlKqBDspVYI9g12BnZQqwU5KlWAnpUqwk1Il2EmpCuyZlCrBTkqVYM9gF7yMl/HtEuz4dgl2fPsXvHqanhetr73Yt2d8uwQ7vl2Bfce3S7Dj2yXYWV2SYGd1SYI9g12BnZQqwU5KlWAnpUqwk1Il2Empip8DH6RUCXZSqgQ7KVWCnZQqwZ7BrsBOSpVgJ6VKsJNSJdhJqRLspFQF9pOUKsFOSpVgJ6VKsJNSJdjx7eOx78+L1h/rGb/taP3Pi7f8sN5yLm5/fWLy/TUiEfhrRHyw1+gia/hrRDDx14gU468Rkcdfo4xG9hqx5OevEd5bq9GV8gt1ukoK3Thvd4Xo6rQK3fdrxrvcpnLCtLlCidN5xQqty7Mz7K9/T1Ej+gV/jegX/DWiX/DXKKORvUb0C/4akY38NSId+WvEewz+GtGl2mvEaeJyjc7n4jWlokb0DP4a0TP4a0TP4K9RRiN7jegZ/DWiZ/DXiJ7BXyN6Bn+N6BnsNUr0DP4a0TP4a0TP4K8RPYO/RhmN7DWiZ/DXiJ7BXyN6Bn+N6BnEGn3YttfFH+6gqBE9g71GGz2Dv0b0DP4a0TP4a0TP4K9RRiN7jegZ/DWiZ/DXiJ7BXyN6Bn+N6BnsNcr0DP4a0TP4a0TP4K8RPYO/RhmN7DWiZ/DXCO+t1mh/a7SfJY12vLe/RngGtUZnejT6dbMFjTIa2WuEZ/DXiLUJf41Ym/DXiLUJf43IR/YaHeQjf41Ym/DXiLUJf43oGb5Towd7Bvt47Pf1uvxYy/+10wZIsBPwJdjJ7BLsxHAJdpK1AvtJWJZgJ/9KsBNpJdhJqRLsGewK7KRUCXZSqgQ7KXU89mNfH+x7sYE8SakS7KRUBfaLlCrBTkqVYCelSrCTUiXYM9gV2EmpEuykVAl2UqoEO3FpOPa0Pq8nffyx+CvOm7gkwU5ckmAnLkmwE5ck2DPYFdiJSxLsxCUJduKSBDuLehLspFQB9m0hpUqwk1Il2EmpEuykVAn2DHYFdlKqBDspVYKdlPqX2B+SBM9RJMmSg0iuxMNRJEl8o0hmSIq3xGltvfsBB43sNcIw+2uEu/bXCN/urxGJwF6jRNbw14gU468Ri1xqja78aHSXNWJFzF+jjEb2GtEz+GtEz+CvET2Dv0b0DO5bwW+JnsFeo42ewV8jegZ/jegZ/DWiZ/DXKKORvUb0DP4a0TP4a0TP4K8RPYO/RvQM9hplegZ/jegZ/DWiZ/DXiJ7BX6OMRvYa0TP4a0TP4K8RPYO/RvQM9hrt5COtRvf9mvG+96JCpCN3hchG7gplFDJXiFzkrhCpyF0hMpG7QiQid4VYdzVX6GDV1V0hOgV3hegU3BWiU3BXKKOQuUJ0CuL1h2Vd3p+9FTWiVfDXiF7BXyOaBX+N6BbsNTppF/w1ol/w14iGwV8jOgZ/jTIa2WtEz6DWKD23suSlqBE9g79G9Az+GtEz+GtEz2Cv0UXP4K8RPYOR965oRM9gn48uegZ/jTIa2WtEz+CvET2Dv0b0DP4a0TP4a0TPYK/RTc/grxE9g79G9Az+GtEz+GuU0cheI3oGf43oGfw1omfw14iewV8jegZ3jfJCz+CvET2Dv0b0DP4a0TP4a5TRyF4jegZ/jegZ/DWiZ/DXiJ7BXqOVfKTV6Er5hTpdRYVIR2KF8gvfdRxFhchG7gplFDJXCD/nrhBuzl0h1ozMFUqsGLkrRB5yV4g85K4QechdoYxC5gqxTuSuEKtE7grRKYgVuh7Ud7HbTnQK7grRKZgrtNEpuCtEp+CuEJ2Cu0J0Cu4KZRQyV4hOwV0hOgV3hegU3BWiU3BXiE7BXKFMp+CuEJ2Cu0J0Cu4K0Sm4K5RRyFwhOgV3hegU3BWiU3BXiE7BXSE6BXOFdhKru0IkVneFSKzuCmUUMleIxGqu0PG9z6FzfV2crv1sKLQu65oeMuuefiPzTLD9+Anyj59g//ETHD9+gvPHT3D9+Anunz7Bufz4CdYfP8GPfyafP/6ZfHo/k/frPcG5thzjdT4G87r3kg08vR/gw8f1ftoPH9fbGgwf19tHDB/X23SMHvfydijDx/W2M8PH9fY+w8f1NkrDx82xxo3lqq5YruqK5aquWK7qiuWq7liu6o7lqu5YruqO5aq++cxj+bixXNUdy1XdsVzVHctV3aFc1b6EclX7EspV7UsoV7UvoVzVvuRY44ZyVfsSylXtSyhXtS+hXNW+xHJVayxXtU703E3r8/Lyxx9zcdyJnrs940703O0Zd6Lnbs+4Ez13e8ad6LnbM+5Ez92OcdNEz92ecSdqM3rGnajN6Bk3lqv65lOI5OPGclUplqtKsVxViuWqUixXtcVyVVssV7XFclVbLFf1zecwyMeN5aq2WK5qi+WqtliuaovlqnIsV5Vjuaocy1XlWK7qm3eilo8by1Vl6wdR+rQ3REr5t3FfE+zWz5auCay/UNL5aYLraPwn95+vfya2/k75komtv1a+ZGLrvPYlE1tHti+Z2Dq1fcnE3s/LL5j48H6+fsXE1vHtSya2TnBfMnE4z+W9r+mXTBzOc3nvm/olE4fzXN77sn7JxOE8l/e+r18ycTjP5b2v7JdMPJHnSul+TjfY1ncR+6la9d60dvy4E7mtlM7lPW4qjjvRYzjt2+uIjI8/XsVxJ3oGd4zrva3p+HEnevr2jDvRo7dn3Jmeux3jzvTc7Rh3pudux7gTVRw9407Ub/SMG8tVeW9rOnxc730+x48by2Z47/M5ftyZHkTX9cT7e1k+j/vPi7f8zLjlXAzH3ttGitnM9IgbzWam5+FYNof37pViNjMZi9FsZnIho9nMZFlGs8mwqbKZqXMZzSbqM/xK+TViKiWGw3unRCmZqFnqfpZV7+J2k4f3lnVKMt77n30hmXVZl/dnb0U2Uf1wD5uofriHTVQ/3MMmw6bKJqof7mET1dv0sInqbnrYRO2Je9hEzZgdbLx3sPtSNudrt4N1TcVuwnu7OzGbuL64zSauL26zybCpsonri9ts4vriNpu4vrjNJq4vbrOJ64ubbLz3IBSzwRfX2eCL62zwxXU2GTZVNvjiOht8cZ0NvrjOJqwvTulh83mLzc9swvriNhvz/VO1bML64g42YX1xB5uwvriDTYZNlU1YX9zBJqwv7mAT1hd3sMEX19ngi6tsZtr3eDgbfHGdDb64zgZfXGeTYVNlgy+us4n7DN/fbD7fypvNTPvoDmcT97v4/dnp180W2MT9Lm6ziftd3GYTt6Nos4nbUbTZxO0o2mzi+psmm6m2KR7NJm5H0WYTt6Nos8EX19lk2FTZ4IvrbPDFdTYxfPEzbgyr+4wbw72+xr1jGNJn3Bge8xk3hm18xo3hBJ9xc6xxY/i1Z9wYFuwZN5arCrKp+DNuKFd1TrVN8X08n36f5XFnehB1jDvTV9V93f+6fFuWVBx3pq+qjnFn+qpqjzvVHscd484UADvGnSkAdow71XO3Pe5Uz932uDMFwI5xJwqA58sxn3tx1IkcVWvUidxUa9SJnFRj1Jn2tm+NOpGDao06kXtqjTqRc2qNmuOMOpFjao0axy3NtNF4a9Q4FmKmbcBbo8axEDNt0r29f9u2pe0ojjuRjegZN8cadyI70TPuRJaiZ9yJSpiecSdyUR3jzrQr7pb26xn3KJanM2102zPuTF9V2/qMu21FVzXTtqI94870VdUx7kShr2Pcmfbz7Bl3ovDXM+5Mz92OcWd67naMm2ONO1MA7Bh3Kld1vW57y0t53KlcVXvcqVxVe9ypXFVz3Jl2g+wZdyZXldf3uLmYd2fas7Fn3JlcVce4Oda4M7mqjnFnclUd487kqjrGnclVdYw7k6tqjzvT/pw948ZyVWcsVzXThqo94+ZY48ZyVTPtZNozbixXNdN+oz3jxnJVM+0K2jNuLFc1096dPePGclUz7bDZM24oV3XNtPdF+zWya6a9L7Z0Lc+4910ad6bdEXrGneqdyPa4M30zd4w71cv57XGnejm/Pe5UL+e3x53qudseN9Zzd6bdEnrGnSnvdow71Ruv6dmmZ9tycdyp3nhtj5tjjTvVG6/tcad647U97lRvvLbHneqN1/a4U73x2hx3pg0kesad6ndE2/u3CPtaHHcqV9UedypX1R43xxp3KlfVHncqV9UeN9Svs6+pNpLoGDfUr7OvHOrX2VcO9evsa6pdUTrGDfXr7CvnWOOG+nX2FWvPmyvWnjdXrD1vrlh73lyx9ry5Yu15c8Xa8+aKtefNFWvPmyvWnjfXXHvetMeN5arm2vOmOe5cm8C0x41lM6baBKZj3Fg2Y6pNYDrGnepQ2dYZutdM24T0jDvVobLNcWfaJqRn3KkOlW2PO9Whsu1xQx3mfs20TUjPuFMdKtsed6J43zPuTPF+WZ6fK3/8o8VxZ4r3HePOtGjSHneqbUI6xp2pzegYd6Y2o2PcqVxV6zD3a6ZtQnrGncpVtcedylW1x52qq2qPO1VX1R53qq6qOe49VVfVHneqrqo97lRdVXvcWK7qzrHGjeWq7liu6o7lqu5YruoO5aruJZSrupdQrupeQrmqewnlqu4lxxo3lKu6l1Cu6l5Cuap7pg2Le8aN5apm2rA4fSzwvT79wy5+Hrfw4WnfXp+d9rPIZqaH9Gg2Mz3RR7OZ6fE/ms1MXmE0m5mMxWg2M7mQ0WxmsiyD2cy0MfQfsrnyw+Yus5mpYhrNJq4vbrOJ64vbbDJsqmzi+uI2m7i++P3Z6dfNFtjE9cVtNnF9cZtNXF/cZDPT1t7D2cT1xW02cX1xm01cX9xmk2FTZRPXF7fZ4IvrbPDFdTb44jobfHGVzUybsw9ngy+us8EX19ngi+tsMmyqbPDFdTb44jqbqP7mvl/X3ndpS8B7pk3SB5OJ6m3aZKI6mzaZqL6mTSZDpkImqqdpk4nqaNpkovZ8bTJRW742GTxwhcxMO/gPJoMHrpHBA9fIhO32lnV5f/ZWZJNhU2UTttvrYBO22+tgE3bNu4NN2DXvDjZh17zbbKY6W2M0m7Br3h1swq55d7CJ64vT+Xx2XopsMmyqbOL64jabuL64zSauL26zieuL22zwxVU2M52OMtrfzHSUynA2+OI6G/riOpsMmyob+uI6G/riOhv64job+uI6G3xxlc1U59uMZoMvrrPBF9fZ4IvrbDJsqmzwxXU2+OI6G3xxnQ2+uM4GX1xhk5epTigazQZfXGeDL66zwRfX2WTYVNngi+ts8MV1NlH9zZVeWxRf6SqRWaO6myu/7uQ6jiKZqN6mTSaqs2mTifp8apOJ+nRqk4na2bTJRG1s2mTC+pkWmbAnA7XJ4GdqZPAzNTJRe5o2mQyZCpmwHvh6RryLWTvsaUBtMmE9cJNMWA/cJBPWA7fIhD0FqE0mrAdukgnrgZtkwnrgJpkMmQoZPHCNDB64RgYPXCODB66RwQNXyIQ98adNBg9cI4MHrpHBA9fIZMhUyOCBa2TwwDUyeOAaGZxehUzY04/aZHB6NTI4vRoZnF6NjPdTO99vMvv1G5lnAu+na88E3k1QzwTez/GOCcxPWumZwPu52DOB9/OrZwLv50zPBPnHT+Cd0Hsm+PHPZPOTL3om8H4mb/t7gnw1HON6LNvr8mP97C/X97zeT/Dh85qfIzF+Xm93MH5eby8xfl5v5zF+3hxsXm9XM35ebw80fl5vxzR+3mD+yvzsguHzmp9HMH7eYP7K/NyA8fMG81fm+/uPnzeYvzLfh3/8vMH8lfl++ePnDeavzPe1/7N5P+zx6/K8FY63+hh3JnvVMe5M7mq7tve4a3HcqR6++/r85d1Tcdypnr3tcad69LbHnerJ2x53qgfv/fr09Vzvwrir+b7Zw8edqtZojztVq9Eed6pS4/0W5ZmW4rgzPXev87n8uvfiuBN9M39En9duyGkt7oa8mu/5O3zcib6Ze8ad6Ju5Z9yJvpl7xs2xxp0o7/aMO9Fzt2fcifJuz7gT5d2ecWO5KvOdh4ePG8tVme8R/IfjHtsz7pGL407lqtrj5ljjTuWq2uNO5ara407lqtrjTuWq2uNO5aqa45rvZTt83KlcVXvcWK7KfCvZ4eNOtXrfXDQx38Bz+LhTrd63x51p9f5Kz4LntRfzrvn+mcPHnWn1vmPcmVbvO8adafW+Y9wca9yZ3onsGHeqdzPa487kqjrGnclVdYwby1WZ71U5fNypXFXzNTLzXSWHjzuVq2qPm2ONO5Wrao8b641X861Ah487latqjzuVq2qOa74j6fBxY7kq871Oh48by1WZ76I6fNxYrmqqvUH3Z8Hzw0/89gvPf1685WfGLedUZDPTQ3owm6n2HB3NZqbH/2g2M3mF0WxmMhaj2WTYVNnMZFlGs5mpNRrNZqaKaTCbqfbA/BM2V8qvEdNVJBP1Cd4mEzVL3fdrZ527nDKn2tFuKJmpdkf7EzLr8vyi79e/p8gmqh/uYZNhU2UT1Q/3sInqh3vYRPXDPWyiepseNlHdTZtNmmqPwdFsombMHjZxffH5XLymVGQT1xe32WTYVNnE9cVtNnF9cZtNXF/cZhPXF7fZxPXFTTYz7fA6nE1cX9xmgy+us8EX19lk2FTZ4IvrbPDFdTb44jobfHGdDb64ymamPXr/jE1Kz8Up5SKbsL64g01YX9zBJqwv7mCTYVNlE9YXd7AJ64s72IT1xR1swvriDjZhfXGbzUy7LA9ngy+us8EX19ngi+tsMmyqbPDFdTb44jobfHGVzVTbO/8Zm/3N5vOtfGIT9xneZhP3u/i9IX76dbMFNnG/i9ts4n4Xt9nE7SjabOJ2FE02U+2dPJpNXH/TZhPX37TZxO0o2mwybKpsYvjiZ9yprO59vS4/1rK6U7nX9rhTGdL2uFN5zOa4U20O3THuVE6wPe5U5q497lR+rT1ujjXuVK6qPW4sV3XEclVzbf3dHncmV3Xs6zPuXkxEU23Q3THuTK6qY9yZXFXHuDO5qo5xc6xxZ3JVHePO5Ko6xp3JVXWMO5Or6hg3lquaaVvwtD61+scfi29lzbTXd8+4E9mMnnFzrHEnshk9405kM3rGnchm9Iw7kc3oGXcim9Ex7j1RedMzbixXNdOZDz3jxnJVM53M0DNuLFc10/kJPePGclUznXLQM+6PdVX/mmD7uccLPBP8WO/zTPBj7cwzwY91KM8EcX/q1fqJ4BZ3+/IONnF/6tVmE/enXk02cbcv72DDT9nrbPgpe51N3J96tdnksGyu/LC5y2ziboHQZhPXF7fZxPXFbTZxfXGbTVxf3GQTePvy1k+St8Dbl7fZsAVCnQ1bINTZZNhU2bA1WJ0NW4PV2bA1WJ0NW4PV2bA1WJVN4O3L22zwxXU2+OI6G3xxnU2GTZUNvrjOBl9cZ4MvrrPBF9fZ4IurbDK+uM4mqr+579fPkO97L5LJkKmQiept2mSiOps2mai+pk0mqqtpk4nqaZpkwh4C0CYTtedrk4na8rXJ4IFrZDJkKmTwwDUyeOAambDd3rIu78/eimzCdnsdbMJ2e202c51rMJhN2DXvDjZh17w72IRd8+5gk2FTZRN2zbuDTdg17w42cX1xOp/PzkuRTVxf3GYT1xc32Ux1MsVoNnF9cZtNXF/cZoMvrrPJsKn5m6mO3hjNBl9cZ0NfXGdDX1xnQ19cZXPRF9fZ0BfX2dAX19ngi+tsMmyqbPDFdTb44jobfHGdDb64zgZfXGUz02E4w9ngi+ts8MV1NvjiOpsMmyobfHGdDb64zgZfXGeDL66zwRfX2OSfe/bRN7CJ6m+u9Nqi+EpXkUyOSia/7uQ6jiKZqN6mTSaqs2mTifp8apIJe0JQm0zUzqZNJmpj0yYT1s80yWTIVMjgZ2pk8DM1MlF7mjaZqC1Nm0xYD3w9I97FrB32NKA2mbAeuEkmrAdukgnrgZtkMmQqZMJ64CaZsB64SSasB26SCeuBm2TwwBUyYU/+aZPBA9fI4IFrZPDANTIZMhUyeOAaGTxwjQweuEYGD1wjgweukAl7yk+bDB64RganVyOTIVMhg9OrkcHp1cjg9Cpkvvkkm+N87dGfzuVokNnP5zb2c9//80evy/28L7+mpXEfz3L/tuyNu8jLc3Fervutzlm4+Nxfm9idn877SyUd9/T62P3TS+wflz7SrEgjkia/Lt0//fX9LE1CGldpNqRxlSYjjas0O9K4SnMgjas0J9K4SnMhjas0N9KYSnPQBthKQxugl+bTb0M+S0MbYCsNbYBMmqfePMvSZKQRSbPdDWloA2yloQ2wlYY2QCTNsbxWRI/lLkpDG2ArDW2AqzQnbYCtNLQBttLQBqgc2v0a7liXojS0AbbSZKRxlYY2wFYa2gBbaWgDbKWhDbCVhjbAVZqLNsBWGtoAA2mKbcBFG2ArDW2ATJrX+R1HKkuTkUYkzXU0pKENsJWGNsBWGtoAkTTH89rGsaeiNLQBttLQBrhKc9MG2EpDG2ArDW2ArTS0AbbSZKRxleavc00+ny5oz0cDyXK9Lk4pNTdKWtKZXriXdB2N67e0Xy/i6fhtY6Vn3Gumca/lGfe+C+Puyxpr3BRr3C3WuDnWuHuscY9Y40713G2PG+y5e4ca9+9P0f5Z487kqj6GfI27bbk47kyuqmPcmVxVx7g51rgzuaqOcWdyVR3jzuSqOsadyVV1jDuTq2qPm2ZyVdv2VHPbvhbHncpVtcedylW1x53KVbXHzbHGncpVtcedylWt73G3vTjuVK6qPe5Urqo97lSuqjnuNpWrao87latqjzuVq2qPO5Wrao+bY407latqjxvLVW2xXNUWy1VtsVxVjuWqcixXlWO5qhzLVf39SbU/a9xYrirHclU5lqvKsWzGHstm7LFsxh7LZuyxbMY+0YMo3cfr5zrpPpfiuBM9iHrGnSje94w70XO3Y9xjouduz7gTPXd7xp3oudsz7kTP3Z5xc6xxJ4r3PePOFO+X5XXb25LO4rgzxfuOcWdaNOkYd6Y2oz3uOVOb0THuTG1Gx7hTuarreVt9WVJx3KlcVXvcHGvcqVxVe9ypuqr2uFN1Ve1xp+qq2uNO1VU1x72m6qra407VVbXHjeWqrliu6u+3jf9Z48ZyVVcsV3XFclVXLFd1xXJVdyxXdcdyVXcsV3XHclV/v/3uzxo3lqu6Y7mqmTYs7hk3lKs6ZtqwOF3Xsw/5vfy2el/48LRvr89O+1lkM9NDejSbmZ7oo9lk2FTZzOQVRrOZyViMZjOTCxnNZibLMprNTK3Rn7F5bmVNd5HNTLtID2cT1xe32cT1xW02cX1xm02GTZVNXF/8/uz06XStz2zi+uI2m7i+uM0mri9us4nri5tsZtoHfDibuL64zSauL26zieuL22wybKps8MV1NvjiOht8cZ0NvrjOBl9cZTPTTu7D2eCL62zwxXU2+OI6mwybKht8cZ1NVH9z369r73svkonqbppkZtpPfTCZqM6mTSaqr2mTiepq2mQyZCpkojqaNpmoPV+bTNSWr00GD1wjgweukJlps//BZPDANTJhu71lXd6fvRXZhO32Othk2FTZhO32OtiEXfPuYBN2zbuDTdg17w42Yde822ymOohjNJuwa94dbOL64nQ+n52XIpu4vrjNJsOmyiauL26zieuL22zi+uI2G3xxnQ2+uOpvZjpKZTgbfHGdDX1xnQ19cZ1Nhk2VDX1xnQ19cZ0NfXGdDb64zgZfXGUz1WE4o9ngi+ts8MV1NvjiOpsMmyobfHGdDb64zgZfXGeDL66zwRdX2Ux1nNFoNvjiOht8cZ0NvrjOJsOmygZfXGcT1d9c6XUn16cb+Uwmqru58vEa8TgKZM4lqrdpk4nqbNpkoj6f2mSiPp3aZKJ2Nm0yURubNpmwfqZJBj9TIRP2XKA2GfxMjUzUnqZNJmpL0yaTo5K5nhHvq0gmrAdukgnrgZtkwnrgJpmwHrhJJqwHbpEJewZQm0xYD9wkE9YDN8mE9cBNMhkyFTJ44BoZPHCNDB64RgYPXCODB66QCXveT5sMHrhGBg9cI4MHrpHJkKmQwQPXyOCBa2RwejUyOL0KmbCnH7XJ4PRqZHB6NTLeT+18v8nsv1//TOD9dO2ZwLsJ6pnA+zneM4H387ZjAvMTUXom8H5+9Uzg/ZzpmcA7+fdMkH/8BD/+mWx+8kXPBD/+mWx+ikTPBN7P5G1/T5Cb1x/L9rr8WD97/PWZ1/z8hvHzej/vx8/r7Q7Gz+vtJcbPm4PN6+1Txs/r7WrGz+vtgcbP6+2Yxs8bzF+ZnwMwft5g/sp8v/7x8wbzV+b76o+fN5i/Mt//fvy8wfyV+T714+cN5q/M95MfP+9M/iovz/FreSsdMXaab/s+fNyZ3NV2be9x1+K4Uz189/X5y7un4rhTPXvb40716G2PO9WTtzmu+YbVfzju/dqKZT3XuzjuVL1Ge9ypao32uFO1Gu1x80zjvt9kPVPRVd0zPXev87n8uvfCuJf5drt/NO5H9HntSJ3W4o7Ul/keusPHneibuWfcib6Ze8ad6Ju5Z9yJ2uaecSfKuz3jTvTc7Rl3orzbM+5EebdjXPNNf4ePG8tVmW/PO3zcqVzVsT3jHrk4bo417lSuqj3uVK6qPe5Urqo97lSuqj3uVK6qOa75NrLDx53KVbXHncpVtceN5arMt2YdPu5Uq/etRZPLfEPM4eNOtXrfHNd868o/XBJLz4LntRfzrvl+lMPHnWn1vmPcmVbvO8ad6LnbM+5Mv0joGHemdyI7xp3q3Yz2uDO5qo5xZ3JV7XHNt4kcPm4sV2W+oePo18jyVK6qPW6ONe5Urqo97lSuqj1urDdezbcCHT7uVK6qOa75JqPDx53KVbXHjeWqzPc6HT5ujjVuLFdlvuXq8HFneu7uz4Lnul+//cLznxdv+Zlxy7n0c9Brqn1ER7OZ6Yk+ms1Mj//RbGbyCqPZZNhU2czkQkazmcmyjGYzU2s0ms1MFdNgNlPtgfknbK70upPr0418JhP1Cd4mEzVL3fdrZ527nDKn2tFuLJmof5vW5flF369/T5FNhk2VTVQ/3MMmqh/uYRPVD/ewieqHe9hE9TYdbKbaNnA0m6g9cQ+bqBmzh01cX3w+F6+p2E1MtdXhaDZxfXGbTVxf3GYT1xe32cT1xW02cX1xi80906atw9nE9cVtNnF9cZsNvrjOJsOmygZfXGeDL66zwRfX2eCL62zwxVU2M227O5xNWF+c0nNxSrnIJqwv7mAT1hd3sMmwqbIJ64s72IT1xR1swvriDjZhfXEHm7C+uM1mpo2Th7PBF9fZ4IvrbPDFdTYZNlU2+OI6G3xxnQ2+uM4GX1xlM9X2zn/GZn+z2c8im7jP8DabuN/F7w3x06+bLbCJ+13cZhP3u7jNJm5H0WQz1XbIo9nE7SjabOL6mzabuP6mzSbDpsombkfRZhPDFz/jTmV17+t1+bGW1Z3KvbbHncqQNsedanPojnGnso3tcadygu1xpzJ37XFzrHGnsmDtcadyVe1xY7mqPZarmmvr7+a4U+3mfezrM+5eTERTbdDdMe5Mrqpj3JlcVce4Oda4M7mqjnFnclUd487kqjrGnclVdYw7k6tqj3vGclUzbQue1qdW//hj8a2smfb67hk3xxp3IpvRM+5ENqNn3IlsRs+4E9mMnnEnshkd4850gEDPuBOVNz3jxnJVM5350DNujjVuLFc102ELPePGclUzHYnQM24sV/VzDy54JvixRumZ4Md6n2eCH2tnngnyj58g7k+9mj8RjLt9eQebuD/1arDZl7jbl3ewiftTrzYbfspeZ8NP2etsMmyqbOL+1Ou5lTXdZTZxt0Bos4nri9ts4vriNpu4vrjJJu725R1s2AKh8pPkDzZsgVBnwxYIdTYZNlU2bIFQZ8PWYHU2bA1WZ8PWYHU2bA1WZRN4+/I2G3xxnQ2+uM4GX1xnk2FTZYMvrrPBF9fZ4IvrbPDFdTb44iqbDV9cZ4MvrrPJQdnc9+tnyPe9F8lEdTdtMlG9TZtMVGfTJhPV17TJRHU1TTJhjwFok4nqaNpkovZ8bTJRW742mQyZChk8cI0MHrhGBg9cIxO221vW5f3ZW5FN2G6vzWauowoGswnb7XWwCbvm3cEm7Jp3B5sMmyqbsGveHWzCrnl3sAm75t3BJq4vTufz2Xkpsonri5tspjpsYjSbuL64zSauL26zieuL22wyz/AqG3xx1d9MdfTGaDb44job+uI6G/riKpupjgsZzYa+uM6GvrjOhr64zibDpsoGX1xngy+us8EX19ngi+ts8MVVNjOdbzOcDb64zgZfXGeDL66zybCpssEX19ngi+ts8MV1NvjiOht8cZXNzz2h6BvY4IvrbHJQNld63cn16UY+k4nqbq58vEY8jiKZqN6mTSaqs2mRWcOeEdQmE/Xp1CYTtbNpk4na2LTJZMhUyOBnamTwMzUy+Jkamag9TZtM1JamSSbseUDX9Yx4X0UyYT1wk0xYD9wkE9YDN8lkyFTIhPXATTJhPXCTTFgP3CQT1gM3yYT1wC0yYc/+aZPBA9fI4IFrZPDANTIZMhUyeOAaGTxwjQweuEYGD1wjgweukAl7zk+bDB64RgYPXCOTIVMhg9OrkcHp1cjg9GpkcHoVMn9/ks32bLt/5Lz/ZzLrvT6bvN3X3SbzPj9vSdfRuH5L+/Wvy7d0pOK4aaZxr+UZ976L4+6xxj1ijXvGGveKNe4daty/P2TjZ4071XO3PW6s5+7fn27xs8bNscadyVV9DPkad9tycdyZXFXHuDO5qo5xZ3JVHePO5Kra4x4zuaqOcWdyVR3jzuSqOsadyVV1jJtnGnd7qrltX4vjTuWq2uNO5ara407lqtrjTuWq2uNO5aqa455Tuar1Pe62F8edylW1x53KVbXHncpVtcfNscadylW1x53KVbXHncpVtcedylW1x53KVTXHvWK5qiuWq7piuaorlqv6+63Wf9a4sVzVFctVXbFc1RXLVV2xXNUdy1XdsVzVHctm/P2O5z9r3Fg2445lM+5QNiMtEz2I0n289otM97kUx53oQdQz7kTxvmfciZ67PeNO9NztGXei527PuBM9d3vGnei52zPuRPG+Z9yJ4n3HuOtM8X5ZXre9ffyjxXFnivcd4860aNIx7kxtRse4Oda4M7UZHeNO5aqu5231ZUnFcadyVe1xp3JV7XGnclXNcdNUXVV73Km6qva4U3VV7XGn6qra4+ZY407VVbXHjeWqUixXlWK5qhTLVW2xXNUWy1VtsVzVFstV/f1OvT9r3FiuaovlqrZYrmqL5aq2WK4qx3JVM21Y3DNuLFc104bF6bpet5Lu5bfV+8KHp/3Z1TvtxQWlmXY3Hs5mpif6aDYzPf5Hs5nJKwxmM9OOzMPZzORCRrOZybKMZjNTa/RnbJ4zUdZ0l9lk2FTZxPXFbTZxfXGbTVxf3GYT1xe32cT1xe/PTr9u9p9sZtpTezibuL64zSauL26zieuL22wybKps4vriNpu4vrjNJq4vbrOJ64vbbPDFVTYz7Yo+nA2+uM4GX1xngy+us8mwqbLBF9fZ4IvrbPDFdTb44jobfHGVzUw7n/8Rm/u57fsubgk40ybpg8lkyFTIRHU2bTJRfU2bTFRX0yYT1dO0yUR1NE0yM+0oP5hM1JavTQYPXCODB66RyZCpkMED18iE7faWdXl/9lZkE7bb62ATttvrYBO222uy2aY61GI0m7Br3h1swq55d7AJu+bdwSbDpsom7Jp3B5u4vjg9t7Lkpcgmri9us4nri9ts4vriJpuZjiUZziauL26zwRfX2eCLq/5mpqNUhrPBF9fZ0BfX2dAX19nQF9fZ0BdX2Ux1sMxoNvTFdTb44jobfHGdTYZNlQ2+uM4GX1xngy+us8EX19ngi6tspjoaaDQbfHGdDb64zgZfXGeTYVNlgy+us8EX19ngi+ts8MV1NvjiKpupjv/5EzZXem1RfKWrSCaqu7ny8RrxOIpkMmQqZKI6mzaZqM+nNpmoT6cmmbDnA7XJRG1s2mTC+pkmGfxMjUyGTIUMfqZGJmpP0yYTtaVpkwnrga9nxLuYtcOeBtQkE/YsoDaZsB64SSasB26SCeuBm2QyZCpkwnrgJpmwHrhJJqwHbpLBA9fI4IErZMKe+9MmgweukcED18jggWtkMmQqZPDANTJ44BoZPHCNDB64RgYPXCFz4YFrZHB6NTI4vRqZDJkKGZxejQxOr0bG+6md7zeZ/frt+tcE5ifO9Ezg3QT1TOD9HO+ZwPt52zOB93OxZwLv51fPBN7PmZ4JvJN/zwTeCb1ngp/+TM7mJ1/0TPDTn8nZ/BSJngm8n8nb/p4gX63rj2V7XX6snz3++p7X+wk+fl7v5/34eb3dwfh5vb3E+Hm9ncf4eb19yvB5zc8tGD+vtwcaP6+3Yxo/bzB/ZX4OwPh5g/kr8/36x88bzF+Z76s/ft5g/sp8//vx8wbzV+b71I+fN5i/Mt9Pfvy8M/mrj7bmdXneSkeMZfNt34ePO5O72q7tPe5aGtd8k+0//Mu7r89f3j0Vx53q2dsed6pHb3vcqZ687XGnevDer61Y1nO9i+NO1Wu0x52q1miPO1Wr0R53qlLj/SbrmYquKs/03L3O5/Lr3ovjTvTN/BF9XjtSp7W4I3U230N3+LgTfTP3jDvRN3PPuBN9M/eMO1Hb3DGu+QbFw8ed6LnbM+5Eebdn3Inybs+4Oda4sVyV+fa8w8edylUd2zPukYvjTuWq2uNO5aqa45pveTt83KlcVXvcqVxVe9ypXFV73Bxr3KlcVXvcqVxVe9xYrsp8a9bR45rvnTl60cR8Q8zh4061et8ed6Ln7nqlZ8Hz2ot513w/yuHjzrR63zHuTKv3HePOtHrfMe5Mv0hoj2u+cePwcad6N6M97kyuqmPcmVxVx7g51rixXJX5ho6jXyO7pnJV7XGnclXtcadyVc1xzTfsHD5urDdezbcCHT7uVK6qPW6ONe5Urqo9bixXZb7X6fBxY7kq811UB4+7m2+5OnzcmZ67+7Pgue7Xb7/w/OfFW35m3HJORTYzPaRHs5npiT6azUyP/9FsZvIKo9nMZCxGs5nJhQxmM9V+qqPZzNQajWYzU8U0mk3UZ/iV8mvEdBXJRH2CN8lMtU/dn5C5n9u+yylzqh3txpKJ+rdpXZ5f9P369xTZRPXDPWyi+uEONlNtwTeaTVQ/3MMmqh/uYRPV2/SwybCpsonaE/ewiZoxe9jE9cXnc/Gait3EVFsdjmYT1xc32eS4vrjNJq4vbrOJ64vbbOL64jabDJsqm7i+uM0mri9us8EX19ngi+ts8MVVNjNtYTucDb64zgZfXGeDL66zybCpsgnri1N6Lk4pF9mE9cUdbML64g42YX1xB5uwvrjNZqZNiIezCeuLO9iE9cUdbML64g42GTZVNvjiOht8cZ0NvrjOBl9cZ4MvrrI58cV1NvjiOht8cZ1N3Gf4/mazn0U2cZ/hTTZTbS38Z2zeG+KnXzdbYBP3u7jNJu53cZtN3I6izSbDpsombkfRZhPX37TZxPU3bTZxO4o2m7gdRZPNVJtD19k8405lde/rdfmxltWdyr22x53KkLbHzbHGnco2tsedygm2x53K3LXHncqvtcedyoK1xj2m2hy6Y9xQrupYQrmqY66tv9vj5plOw93XZ9w9FcedyVV1jDuTq+oYdyZX1THuTK6qY9yZXFV73Kn2r+4YdyZX1THuTK6qY9yZXFXHuDnWuBPZjLQ+tfrHH3Nx3IlsRs+4E9mMnnEnshkd46aJbEbPuBPZjJ5xJ7IZPeNOZDN6xs2xxp2ovOkZN5armunMh55xY7mqmU5m6Bh3psMWesaN5apmOhKhZ9xYrurnHlzwTPBjjdIzwY/1Ps8EP9bOPBP8WIfymiDu9uXNnwgecbcv72AT96debTY/9un4DWzi/tSrzYafstfZ8FP2Opu4P/Vqs4n7U68rP2zuIpu425d3sInri9ts4vriNpu4vrjNJsOmyoYtEGo/ST4Cb1/eZsMWCHU2bIFQZ8MWCFU2gbcvb7Nha7A6G7YGq7Nha7A6mwybKht8cZ0NvrjOBl9cZ4MvrrPBF1fZBN6+vM0GX1xngy+us8EX19lk2FTZ4IvrbKL6m/u57fvei2SiupsmmbDHAbTJRHU2bTJRfU2bTFRX0yaTIVMhE9XRtMlE7fnaZKK2fG0yeOAaGTxwhUyQrf//R8jggWtkwnZ7y7q8P3srsgnb7XWwybCpsgnb7XWwCbvm3cEm7Jp3B5uwa94dbMKueTfZnHMd3DCYTdg17w42cX1xem5lyUuRTVxf3GaTYVNlE9cXt9nE9cVtNnF9cZsNvrjOBl9c9TdTHb0xmg2+uM6GvrjOhr64zibDpsqGvrjOhr64zoa+uM4GX1xngy+uspnprJjhbPDFdTb44jobfHGdTYZNlQ2+uM4GX1xngy+us8EX19ngi6tsZjrtZzgbfHGdDb64zgZfXGeTYVNlgy+us4nqb6702qL4SleRTFR3c+XjNeJxlMjkqN6mTSaqs2mTifp8apOJ+nRqk4na2bTJRG1s2mTC+pkmGfxMhUzYc4HaZPAzNTJRe5o2magtTZtMjkrmeka8i1k77GlAbTJhPXCTTFgP3CQT1gM3yYT1wC0yYc8AapMJ64GbZMJ64CaZsB64SSZDpkIGD1wjgweukcED18jggWtk8MAVMmHP+2mTwQPXyOCBa2TwwDUyGTIVMnjgGhk8cI0MTq9GBqdXIRP29KM2GZxejQxOr0bm75/a6XqR2fbrP5NJzzL7tnzaon/dC9fm5bk4L58pnoWLP1YU/3Xt+emcvVTit6fXx+6fXh7/uPRBcoRDkl+X7vtZRHKC5N+RXCD5dyQ3SP4NyYBjaqZDsoLk35EkkPw7kg0k/44kg+TfkcRzr00kkd3rp3d3PyOJ7F4rSAK61yf2nWUk8dzrdv9HJNcSz702kcRzr00k4dzrsbwauGO5i0jCudc2kgySf0cSzr22kYRzr20k8dzr/ZrtWJciknjutYkknnttIVnjudcmknjutYkkXvfaRBKve20iySD5dyTxutcmknjd6yckRfe6hnavZSQB3etrv8YjlZHEc6/X8Z+RpHjutYkknnttIonXvT519LGnIpJ43WsTSQbJvyOJ1702kcTrXptIwrnXNpJw7rWNJJx7bSL5+6Mw1n19x6jtPyPZz+d1l09D/vrHnvvZzO4nm93PbnY/x3fez8fK22Ozc/l+TrP7uczu5/a6n78/5mDw/axm95O+935eR5kcy1G+n83sfrLZ/exm93OY3c9pdj+X2f3cXvezL2b3s5rdj9n38272/bybfT/vZt/Pu9n38272/bybfT/vZt/Ph9n382H2/Xy4fD//vx//8//+L//Hf/0v/9P/+r/8nx//yK//9//6b//zf/+v/9t/+9f//O//z//+//8/Hxf/fw=="},{"name":"get_portal_address","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"exit_to_l1_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"7Z3vjltFFsTfJZ+jVZ8/fU43r7JaoQABRYoSRMJKK8S7r0N8rz3KZZpR3OVqhi9AQsf16zupOm277Pvbix9ef/frT9++effj+w8vvvn3by/evv/+1cc379+dfvXb7y9ffPfLm7dv3/z07fVvvyh//ONfon/8iQ8/v3r36Tc+fHz1y8cX35SXL16/++H079Of/vHN29cvvgn5/T8vP623J673J66vT1wfT1yfT1zfnri+P229lr+8/uUXy7rleWGvuS+VyIO1LlLPi13UL6ulHawO9XZeHRoPV3/mlq/gliJ+XinFHEyuX3PF07Yr3kdXXLTsu9QoA+70FufVWbUfcNtNuE8X/CH45wf3mQ9eZz54zHzwnPngbeaD94kPbmXmg8vMB9eZDz7ToTbToTbToTbToTbToTbToTbToT7ToT7ToT7ToT7ToT7ToT7ToT7ToT7ToT7ToT7ToXWmQ+tMh9aZDq0zHVpnOrTOdGid6dA606F1pkPrTIfGTIfGTIfGTIfGTIfGTIfGTIfGTIfGTIfGTIfGTIfmTIfmTIfmTIfmTIfmTIfmTIfmTIfmTIfmTIfmTIe2mQ5tMx3aZjq0zXRom+nQNtOh7dCh2rqe/5j2OpBQSdkWS+q+2PT8MnpLgEYDaPSv19CyveWgau2BxsEPr21A1299fHo/5oulYn17YHHx68V/sPeyMLsszK4Ls9vC7L4we12YPRZmz4XZ28LsC89VKQsPVikLT1YpC4/W02F8ZfiFh6uUhaerlIXHq5SF56uUhQeslLkT9rOI3GISRu4irQKvkMjK8LoyvK0M7yvD15XhY2X4XBm+rQzfF4bXlSesrjxhdeUJqytPWF15wurKE1ZXnrC68oTVlSesrjxhbe6EPYvcYBKabgUAtQq9QroyvK0M7yvD15XhY2X4XBm+rQzfF4b3sjL8yhPWV56wvvKE9ZUnrK88YX3lCesrT1hfecL6yhO2rjxh69wJexa5wSSsshXgtWociRhCxBEiFSESCJFEiDSESAeIREGICEIE4fhAOD4Qjg+E4wPh+EA4PhCOD4TjE+H4RDg+EY5PhOMT4fhEOD4Rjk+E4xPh+EQ4viEc3xCObwjHN4TjG8LxDeH4hnB8Qzi+IRzfEI7vCMd3hOM7wvEd4fiOcHxHOL4jHN8Rju8Ix3eA47UUhIggRBQhYggRR4hUhEggRBIh0hAiCMcLwvGCcLwgHC8IxwvC8YJwvCAcLwjHC8LxgnC8IhyvCMcrwvGKcLwiHK8IxyvC8YpwvCIcrwjHG8LxhnC8IRxvCMcbwvGGcLwhHG8IxxvC8YZwvCMc7wjHO8LxjnC8IxzvCMc7wvGOcLwjHO8Ix1eE4yvC8YjOnSI6d4ro3Cmic6eIzp0iOneK6NwponOniM6dIjp3iujcKaJzp4jOnSI6d4ro3Cmic6eIzp0iOneK6NwponOniM6dIjp3iujcKaJzp4jOnSI6d4ro3Cmic6eIzp0iOneK6NwponOniM6dIjp3iujcKaJzp4jOnSI6d4ro3Cmic6eIzp0iOneK6NwponOniM6dIjp3iujcKaJzZ4jOnSE6d4bo3Bmic2fFESIVIRIIkUSINIQIwvGIzp0hOneG6NwZonNniM6dITp3hujcGaJzZ4jOnSE6d4bo3Bmic2eIzp0hOneG6NwZonNniM6dITp3hujcGaJzZ4jOnSE6d4bo3Bmic2eIzp0hOneG6NwZonNniM6dITp3hujcGaJzZ4jOnSE6d4bo3Bmic2eIzp0hOneG6NwZonNniM6dITp3hujcGaJzZ4jOnSE6d4bo3Bmic2eIzp0hOneG6NwZonNniM6dITp3dpMSWd0X1+pHIg0gcovqVdS+LY7MIxFFiBhCxBEiN4j6tH1x1v5A5MvV3bbvpO2h+1oV24CCDSjZgBobUCcDukWt7LZAwgakaKC+AUmx8oDoy8VR2nlxlMsDS9eN3pam96Xp69L0sTR9UtPvmRNejujb0vR9ZfpelqaXpem5Z23s9HlIzz1rR/Tcs3ZEzz1rR/Tcidm2Z8bR5Ut6L9yJOaKndm3L7ZzTpR7RU7v29Ixqo087oqd27ZCe+oQ8pKc+IQ/pqU/IQ3rqvB/RC3XeD+mpT8hX9E2P6KlPyEN66lnbY78nXcsjeu5ZW+vj9NyzdkTPPWtH9NyzdkRPPWullMvq0o74uadt98fx/+QTA71t74ZbkXwcX1K2aJO0y1vnrR8srqc3Fs+Lq13dnFPkaK9VdV99elt+sLpV3/6utdrLg9Xn3cqz2q0+q93as9qtP6vd1me123hWu030bveTeD094xnw5358ybh0qU6CG31bmr6vTG9laXpZml6Xprel6Z2afn8yk1Ef0B88PdmLFt1ssDbrtjbb5aqobxel/nNRvrwo8c9F+fKicB847nRRuM8xd7oo3Mej+1wU5z513emicB/m7nRRuM+Id7oo3EfPO10U/+eifHlR/uREu9e99Pp90ON3FlS212pUq4322X0H6l0PXqs5/nS4lbz8nK5qUMc/Jym5/ZzErkRKpXtp6vhz6n/f7bbntd3+rLZ7/C0Cf9/tCny7T5kpp9/V/bGvq6Np2wZ09Q3Y6hvw1TdQV99ArL6B4xPEhclE6+MbOL1Btp3KTu82xQAprO+NdBc/CsY/mfKxX1MpMTprx/4S9em/rz51YHK4/rpFI3Z0nTohVBRGKGGEUkYoY4RyRqjKCBWMUMkIxZjowZjoyZjoyZjoyZjoyZjoyZjoyZjoyZjoeYecqm2Hqu1y/K9xZmqFkOkO3ovLU7dQOWByQqZKyBSETEnI1AiZOh9TL4RMQsg0+xB1lrlFNKfsL2Vlan71XO3OCFUZoYIRKhmhGiNU54OqpTBCCSOUMkIRJnothIleC2Gi10KY6LUQJnqVO0TC4JluFSVkusNf88HptkoQMiUhUyNk6nxMWgiZhJBJCZmMkMknM51lbhLNcSWTXz9XNRihkhGqMUJ1QigrjFDCCKWMUMYI5YxQjIlujIlujIlujIlujInud4iE0TNdd0KmO/w1H51uvREydT6mWgiZhJBJCZmMkMkJmSoh0+zzylnmFtHcbN9L9qvNXMk0jMw4QL09LtNl/7RyP/2QLlNfysFqPR1Mzqs18upeR8efupPYPorSVNqD1Z838Bc+MkG+AVl9A7r6Bmz1DfjqG6irbyBW30CuvoG2+gZWn8S5+iTO1Sdxrj6Jc/VJ/Bc+mkO+gdUnca4+iXP1SZyrT+JcfRI3+CTOvr3QoK30IyThQ1I+JONDcj6kyocUfEjJh9T4kDodUudL786X3p0vvTtfene+9O586d350rvzpXfnS+9Ol95R6NI7Cl16R6FL7yh06R2FLr2j0KV3FLr0jkKX3lHo0jsKX3oLX3oLX3oLX3oLX3oLX3oLX3oLX3oLX3oLX3oLX3orX3orX3orX3orX3orX3orX3orX3orX3orX3orX3obX3obX3obX3obX3obX3obX3obX3obX3obX3obX3o7X3o7X3o7X3o7X3o7X3o7X3o7X3o7X3o7X3o7X3pXvvSufOld+b69IO7x6eAhUyVkCkKmJGRqhEydjykKIZMQMikhE2GOB2GOB2GOxx1yfPDNExF839YTwfdtPRF839YTyfdtPZF839YTyfdtPZF839YT6YRMfN/WE0mY40mY40mY40mY440wxxthjjfCHG+EOd4Ic7wR5ngjzPFGmOONMMc7331H4h63lhsyOSFTJWQKQqYkZGqETJ2OKe9xT7khE9/9o7Lw5XgWvhzPwpfjWfjus5WF7z5bWfjus5WF7z5bWfjus5XCd5+tFL77bKXw3Wcrhe8+WylOyESY44T3S0zC+yUm4f0Sk/B+iUl4v8QkvF9iEt4vMQnvl5hKmONKmONKmONKmOM3uTVf1LozRZavfX53kzvz3ZrJCJmckKkSMgUhUxIyNUKmzsfkhZCJMMedMMedMMf9Djk+Ohd4JWQKQqYkZGqETJ2PqRZCJiFkUkImI2QizPFKmOOVMMcrYY5XwhyvhDkehDkehDkehDkehDkehDkehDkehDl+/NkkbX171VR7LY8zae4fgddT3l2I9OjWQr3vT+6KXR5ZxQ4WR9tuWhT9Ai9dN3phps/m58XZ6xG9Lk1vS9P70vR1afqgps/Y6eOIPpemb0vT95XpG/WsHdJzz9oRPfes3elbOUrMxj1rR/Tcsza3A3WTckTPPWujP07PPWtH9NyzdkRPPWubbqe0ZkfPrRr1rB3Rd+pZO6SnnrVDeupZ2/pG38uRazv1rB3SU8/aIT31rB3SU8/aIT31rG0tdvrDzOGetSN67ln7OH0r3LN2RM89a0f03LN2RM89ay/0R+f7Vrhnbas7fT2i55612R6n5561I3ruWTui5561I3ruWTugF+5ZO6LnnrUj+hvkfa374lr9Af1ZpCJEAiGSCJEbZFHdX7/W2uRIpANEtCBEBCGiCJEbHB3rfkTSKHYk4giRihAJhEgiRBpCpANErCBEBCGiCJFbOD7qJVb0SMQRIhUhEgiRRIg0hEgHiHhBiAhCRBEiCMc7wvF+A8fH/rabxtVzmSuRQIgkQqQhRDpApN7A8WEXEe9HIoIQUYSIIUQcIVIRIoEQSYRIQ4jcwvFiF8cfPTGNghARhIgiRAwh4giRihAJhEgiRBpCBOH4RDj+Fh91iiy7SMaRiCJEDCHiCJGKELmF4/dvVNEsh3+7EiHSECIdIHKLT3KMRQQhoggRQ4g4QuQWjq/94vg8EgmESCJEGkKkA0Ru0ScfiwhCRBEihhBxhAjC8R3h+I5wfEc4vgMc30tBiAhCRBEihhBxhMhkx/9++uV/X/3y5tV3b19/OP2hT//313fff3zz/t35lx//9/Pn/3Na/H8="},{"name":"claim_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"message_leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"_assert_token_is_same","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/92b6W4TMRDHd0OODUtzlbQNR5uWo9za0DaBD0hFHF+QQIInCE2CwhWUtgjel8/wCsSJh/7XSUs99SwqlqL1Lp6Z34zHXmcafG/SUqOPr/sZfT3jTTcas62v0claw6GuSJLTPyWcKQlOBZmekRS+TpzDksSHZz+hX9PXx8Nh+3u9/7nT/VYf7O/VB73628H+587uH8mvuhOAJaLZdhSywCB3pvvBZjM70vEkmI6cp/15qv+Nrr7+hDCe5EPvYBaewjNars/0s9zok9fPyqPP8yBu9+zoU9L99tdPr77sDDrdx53OsLu7izOWhZgc1Y6rL2ehb8nU93L/48d+r98dPvvW392L6Q1m6KXMTM3wB1lmZS/pzBq6tvV9dLI23krIflrrDgxGdR+CfYf53lN684a/5pykoR8C01kZpkYIdvJg75zIHGx2C2APbYRGDOg+BUxzIkzNHjLNWTIVRJham8hUsGQqijDdj5CpaMlUEmFqPkSmkiVTWYYpluNlCyauL9xcOUnsKjDeYewayFSxZJqXYdpBpvmE4ntexJdWG5nOWzJVRZiaW8hUtWRakGGK7b8LwEDnhxfAsAgM7t7NjSg0YkA2PCMu1IgjNPrEuQQ6Ms44o/F7geyhjUWDk+5x/moisZuctc7ow10eYpEOpmOV0c+IRc3xe1+e8agYkc2SN72HqLMgvX//nNPfdEff5oZ/O57Paq6/RqhGaZABjhxwyYR0YwdT3wMb2HDJ1IBJ6Ng/PmKTnUWwdwHsOTxiNwtgD23UjBjQPS7HiyJMrS1kumjBhHJlS18uifjS3ECmS0xfCky5ElNujilXZsoVLeTUXF2G8e7maquHTJeZvlQsfVkW8aUVy7tlpi9cuaplDFZkYnAfmVaYvnDXHjd/uPZs1qyKeR3GO9zv3iJTnelLlSnH3X+4c8XdX7nrisvJtWe7l63CeIc51UGmVaYv3JwqMuW47/oKUy6Jd++/PCPMW8ipXFyD8Q7fKQ+RaY3pi+1554qIL83Y+/EK05f/fV3NJyzHjecCU447D9x3H3f9c89F3Hhyz4tc/05Lfq7BOKrb/NBXtVddBb0OazWd0OAkG57BTo04QujXgPMa6HBd3iR7aOOqwUn3uM9fl4ndDpY3sZRJ5U2MFZU3icUsb0oxHhUjsqn2HJrDRxC3HMhtO+GZ/NykJuLrpMZn/Nrj2HXHJSEmVdelP/EclIn3BsP2u+7rbrvjg12zVoxX/xC/UvAsN6Of8mY3uZyLIqV7XSieSt8NrSujdZMfZDMNY37pa8mbbqiL5GgOSKc6j1Oe4FisrdegT7GV8X8jss3xdWC6IcI0WXdoh643wZ7DeuL4z4JkD22sGzGge3zf0rM5plydKVdlypWZckWmXIUpt5Cw3ApTjjsPywnLceevdEo4uXnNXbcFphzXPxt7aq+8BeMd1iIeINMtpi/cNcONHTcXuXvXKlMu6bhw/Ut6bXPtVROWS/rdyt2bk+bkzh93j+Xu6dwzgM06UnvzbRjvcG9uIdNtpi9VGEffSfpQV7gDeh1+D4md+T2w4Rns1IgjhD7JK867oMN13YjsoY07Bifd47zfk4ldhHWjAOJCdSOMFdWNiCXnxetGUoxHxYhsqv2M5rChr3nNlQskuKIxV6B10/d/spWBmOaN/1LkyH4D7ZNuskXP09Df9w/G5oN4PCkHiF/tg1n6uWRwuFzakCvAmCzI5Qw5uqccV/H7oPnUvP0GiwuQPg45AAA=","debug_symbols":"5ZztSpxXFIXvZX5Leff3Od5KKUETDYJoUFMo4r33bZwxSobatcwOTP2ToO59eM88zwJZw3i/+XR2+vXzh4ur8+vbzfHv95vL648ndxfXV+tX9w9Hm9Obi8vLi88fnn97s3z757f5beH2y8nVP1/f3p3c3G2Ol6PN2dWn9f91+fzi8mxznPJw9MPYtNoOzqinUcnaM+sisR12Uf8+LWPPdKqP7XRqvpz+42h9bFne8NyyiG8nZTH/xU8ub3nFy3av+HztFRddnm6pubzy3OUjt9MVOvc8t/6U515f8JcP/ni4dR7unYdH5+HZeXh1Hj46D5+Nh+vSebh0Ht6ZUO1MqHYmVDsTqp0J1c6EamdCtTOh1plQ60yodSbUOhNqnQm1zoRaZ0KtM6HWmVDrTKh3JtQ7E+qdCfXOhHpnQr0zod6ZUO9MqHcm1DsTGp0Jjc6ERmdCozOh0ZnQ6ExodCY0OhManQmNzoRmZ0KzM6HZmdDsTGh2JjQ7E5qdCc3OhGZnQrMzodWZ0OpMaHUmtDoTWp0Jrbck1LV2xb/ryIejf63b0+bcTqfLnrcJ6i2B/slvWdR/z//j/ADnJzY/FnBewHkF5w2cd3A+wPkE50G+A+Q7QL4T5DtBvhPkO0G+E+Q7Qb4T5DtBvhPkO0G+sizogqALii4YuuDoQqALiS4UujDQBZS0oKQFJS0oaUFJC0paUNKCkhaUtKCkBSWtKGlFSStKWlHSipJWlLSipBUlrShpRUkbStpQ0oaSNpS0oaQNJW0oaUNJG0raUNKOknaUtKOkHSXtKGlHSTtK2lHSjpJ2lHSgpAMlHSjpQEkHSjpQ0oGSDpR0oKQDJZ0o6URJJ0o6UdKJkk6UdKKkEyWdKOlESRdKulDShZIulHShpAslXShptA0TtA4TtA8TtBATtBETtBITtBMTtBQTtBUTtBYTtBcTtBgTtBkTtBoTtBsTtBwTtB0TtB4TtB8TtCATtCETtCITtCNTtCNTtCNTtCNTtCNTtCNTtCNTtCNTtCNTtCNTtCNTtCNTtCNTtCNTtCNTtCNTtCNTtCNTtCNTtCNTtCNTtCNTtCNTtCNTtCNTtCNTtCNTtCNTtCPT/R1Z1tO7pllmz9f2fLpqbdu3w2ujrE/Da82/Zzqsdp+uCnv+ya29b8jG+hLspjX0lekRvnvsEXN5Mb297nxX193fT/5/ryvv67r6vq5r7+u6/suvm7K7gMtrF1i/q09nT/k+Xba7QBz6BfLQL1CHfoFx6BeYB34BXw79Aq//TuDx4+/FrtyacWvOrQW3ltxacWuDW5vUWizcGmdJcJYEZ0lwlgRnSXCWBGdJcJYEZ0lyliRnSXKWJGdJcpYkZ0lyliRnSXKWJGdJcZYUZ0lxlhRnSXGWFGdJcZYUZ0lxlhRnyeAsGZwlg7NkcJYMzpLBWTI4SwZnyeAsGZwlk7NkcpZMzpLJWTI5SyZnyeQsmZwlk7NkUpbYsnBrwq0pt2bcmnNrwa0lt1bc2uDWOEuEs0Q4S4SzRDhLhLNEOEuEs0Q4S4SzRDhLlLNEOUuUs0Q5S5SzRDlLlLNEOUuUs0Q5S4yzxDhLjLPEOEuMs8Q4S4yzxDhLjLPEOEucs4TrXo3rXo3rXo3rXo3rXo3rXo3rXo3rXo3rXo3rXo3rXo3rXo3rXo3rXo3rXo3rXo3rXo3rXo3rXg3vXh/Wr/48ubk4Ob082/4d7/OvVx+f/Vnvu7++PP5kHf4b"},{"name":"get_portal_address_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/71YXW+bMBQ1KSQktGnSrzRLJ/EToMrS7S3V1qdJm7RJ22NEA3RIaZmATNl+/eLUtxzc9IMG90rIF3N97vGxjQ0au7Xa8tKEb0CdbBQzFqWzmbkVYjkqeWoV8tSAZ43I6lghdQL9GsTg8x/g90V5niTeXzu68YOFHc8zOw7ty3h+46fYcAr+gOq82czOYttL0yDJJtfeYnIZZZM0+hfcJU1FaUqE9ApVNyUBKsN+PxzVlxgfzVxUNH7/STyjUhOXtby2RBy1t1g+gBTfWF5Nlj+/EPXUtgt1pGlreXWE7/25/vp7GvvBue8nQVoYM4MV2z1kz8Wrl8A7lvG+zGezKIyC5GIRpVkBt7EGl/s4ibE/yGXd24ebyYr953Fjce9sZqtVTvl1gd2QOJpCB8pf4XwPLYHPJL3QdPBbwKmphpNrSXmotJSMwTBoQz7M0ZI0oPsacNpWwmkUIqftkpx2lHA6GyKnnZKc2ko4nTrIqV2S064STqMPyGm3JKeOGk6FOd4pwemlfXnpXNlEuy7EV6idi5y6JTntqeE0RU57r6TvvpK+nHnIab8kpwMlnEbvkNNBSU6HajgV3r+HwIHOD5+BwxFwqG5vdh1L0oByMEkXMuJhgY97ew8wjMp4Oqt9gfJhjiOJJ93j+B0r0e72rLVl5nlIF928r5Uh6ogLPxNevQLHxzSinHz/kPcSk+XnVlYdn1OOW68ed/Wd11ej4er82mNFe2yN9EFDNevWcfl40Xvs7jvqexYn3lXwLfB8DfL2JM5Yag/0C7+dcB4859vqjZo+Oxx7oEhPjncisAyBTf2gnDrE/BRlh903xKJ2NAaEyc9QNE9OQFOaL31W1BTxxhv2ORSGepbBDZ8wjvt2c76uXCFrRT7meur5utgBtOmticN7vhbkfUiH574o180LfI/0oW5LwuPf4av3L/zbqXIdcTxTYNNcp1wG7GdN6b9VRfldzE/YlIvqdfATlsc24ecGj6H9l/jzdVUXPvKX2+lSuzbE1KFdQ2rXkP73cf1+CZ+P238pThNkDhcAAA==","debug_symbols":"7ZvvauJAFMXfJZ9lmblz/8z4KstStNUSEC1qFxbx3TetSWowNB/a0yTEL0r0zPXcAz+4ziSn7Gm1fH1+yLfr3SGb/z5lm93j4pjvtsXV6TzLlvt8s8mfH64/ztz7y6/0vuDwsti+XR+Oi/0xm7tZtto+Fe/F4nW+WWVz9efZjSwFK4VJrJZ6tRYtey+lmD3xh9rHFrUSx1KtpE31n1lh27sv+PbOc6n0LvAPO/dfSdxClXjqStyTq7skdR2+jaOWahNKLb7pW3wXgTeNX4oHZHFGFhdkcUUWN2TxiCyegMXJIYt7ZHEkoYQklJCEEpJQQhJKSEIJSSghCQ1IQgOS0IAkNCAJDUhCA5LQgCQ0IAkNSEIDklBGEspIQhlJKCMJZSShjCSUkYQyklBGEspIQgVJqCAJFSShgiRUkIQKklBBEipIQgVJqCAJVSShiiRUkYQqklBFEqpIQhVJqCIJVSShiiTUkIQaklBDEmpIQg1JqLUS6tl8tUycfP4T3nwttqC1OKYWsQSr9twlXO/nt+7QC1GtJqEOdRSuTi2ipObu/6VZnVKzNqVm45SaTRNqNropNeun1Cz9dLNaiaU41e6wb1K5t+sjbfOl+TBm8zxm8zJm8zpm8zZm83HM5tOgzQeqzUvDfMv/EVfdKpRC6NCaVFqLH6EQXzJJ7p7JTSb+nslNJsMeM/rJZNjTSz+Z8D2Tm0yGPWv1k8mwR7h+Mhn2ZNhPJsMeOPvJ5D7HNjI5F1d/F/t8sdysygcX1q/bx6vnGI7/Xi7fFOL/"},{"name":"_call_mint_on_token","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"get_token","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/91a3W7TMBROu6ZJm61r99f9r9sY18l+UrjrBLtCAgmeoFtTVGmsqN3QeEWu4Qau4TmoW5/1s9dNs2tHAkuRncQ+5zufj+1jJxlnlLKDK8PLLjyTE9Vp8DycLkUGZYU2cWYM4swAziyBzeEDyQgsY0fh++9QXuP5aa/X/FrrXLWS21r35rrWbdfOuzdXrf5dyz8890EzoWkYos6XrDAm+8VxnB/IeOWPmXEkal/zd5Rn+BUMrhlej9oHzrgXqL43uArO+P0Zf05tK/CMOC0OrjIvN798evf5ottKTlutXtLvY4+5jtjuofRUeXkFeauyvLc3l5eddifpnd12+teCXG+CXFbOOiLn7gQsk6YQlnxHtJ/Va/D7cLo0HKqkP8dlexJGn/NA+g36ezvg8h2JL0w5KBcBU8EOpiiQ9FAeWOmD46QE+lBHUeKA7rOAadYKpriNmGYVMc1ZwVQ/RkxziphKVjAdhoippIhp3gqm+CVimlfEVLaDSfDxsgImXVt0fWUa7ipQ3yB3EWKqKGJasIPpAjEtpMTvohVb6k3EtKiIackKpvgEMS0pYlq2g0mYf5cBA8UPbwDDCmAwtzZHYSBxQDociRdKhCOAMq7tVZDhGsMZDtcF0oc6ViScdI/9t2qFu1GsNeOP9RAvOf8+Vy5/RlhYTPgzBYyPcUQ62fohryUME8b0BregwxjZAzy4A82Dfjsx8tHQ56uOmJ4aI9sZh2KMXAV96BcGY+QY5x7U8ZT5cM0KprowR68pYNKNhZgt61ZsiY8Q07qmLWnEWbr7EhPxp2p8vwH1DfZVHTFtaNqypNlOdd+1aYWDE2F/upmCLdPsh7escBCfI6YtTVt0/SCNMWRiTqpotkvbvrTnMpU9G/PhbahvcA0Vziq2NW1RnZd3rNgSHyKmHU1bdMfjvzKuFlJup8vnsmY7VV+sQX2D40qI52qatuiuj7q+kXb8+L/7/jbUo/3rN54z39sFuQb3q5HqGQ3hCKBcBJx7IMP0GQ3pQx27Ek66x3G7b4e7EM9oqsALndEgV3RGQ1jkMxpbGB/jiHTiGU0EmLDfG0bwjL6Z27F1dM7hOWJ6zJf3wdY9S5gYr7Su3X2T/nDd7TU/Ju+TZisDeuXv0ZhnHrAr+4Btk/66wMRsfmbH5pDJPrDEJ5P3nMtyuWyy4wBspzo/eF527ieURe2oD0gmW+fIT6gu8zPyl314Rv9O0LsC59nzrXAxHNu+L3JBulw4Oy5I/4gY0h+hfpJNuuh5Dsq/nXFdqkd1aB4l/Iz3PC8jfrldTmpXgjp5aOdJ7Tzp3xrG3y9eZv32FzcXiHY/JgAA","debug_symbols":"5ZvRSiNBEEX/ZZ7DMlVdVT3tryyLRI0SCFE0LiySf99ZTaKyYbMHLSHkRUlyu+maw3m5ST91V7OLx5vz+fL69qE7+/7ULW4vp6v57XJ89bSedBf388VifnP+9u2uf/7zrT0veLibLv+8flhN71fdWT/pZsur8f+4+Hq+mHVnIevJX7FW6ibYvO6iEnVP1kR8EzZRe03LsCcdasMmHRrv0z8m47Gl/8C5pRfbJKUv9sUnl4888Vq2T7wdeuKi/W5Kjf7AuasNsUlX17bn3Pop5x4f+PuDv2xeMje3zM09c/PI3Lxmbj5kbt4SN9c+c3PJ3DzTUM00VDMN1UxDNdNQzTRUMw3VTENLpqEl09CSaWjJNLRkGloyDS2ZhpZMQ0umoSXTUMs01DINtUxDLdNQyzTUMg21TEMt01DLNNQyDfVMQz3TUM801DMN9UxDPdNQzzTUMw31TEM909DINDQyDY1MQyPT0Mg0NDINjUxDI9PQyDQ0Mg2tmYbWTENrpqE109CaaWj9f0Nf8gHzFeYHmG8sP/QwLzCvMF9g3mAe8h0g3wHyHSDfAfJtkG+DfBvk2yDfBvk2yLdBvg3ybZBvg3yl7+kCoQuULih0gdEFThcEXVDpgoEuoKSFkhZKWihpoaSFkhZKWihpoaSFkhZKWilppaSVklZKWilppaSVklZKWilppaQLJV0o6UJJF0q6UNKFki6UdKGkCyVdKGmjpI2SNkraKGmjpI2SNkraKGmjpI2SdkraKWmnpJ2SdkraKWmnpJ2SdkraKemgpIOSDko6KOmgpIOSDko6KOmgpIOSrpR0paQrJV0p6UpJ0y5MaBkmtA0TWocJ7cOEFmJCGzGhlZjQTkxoKSa0FRNaiwntxYQWY0KbMaHVmNBuTGg5JrQdE1qPCe3HhBZkQhsyoRWZ0I5MaUemtCPT/R2Zt2F3EaDvY/3PbybGfmd7lWLsVXQXHsuuPWkvdftbfS9v7wHs/WW/q+7S6nogPbhtbzsM3vp36c245bTGtdMa109r3DitcetpjTt8+bgh2wFMDg0wvqu7vZu8pmvZDtCOfID931sc0wBy7APosQ9Qjn0AO94B1uPLn9P7+fRiMdvcJr5+XF6+uVy8+nX38skY/g0="}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"TokenBridge::_call_mint_on_token_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::_call_mint_on_token_parameters","fields":[{"name":"amount","type":{"kind":"field"}},{"name":"secret_hash","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::exit_to_l1_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::exit_to_l1_private_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::get_token_abi","fields":[{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::_assert_token_is_same_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::_assert_token_is_same_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"TokenBridge::claim_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::claim_private_parameters","fields":[{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::get_portal_address_public_abi","fields":[{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::claim_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::claim_public_parameters","fields":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"message_leaf_index","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::constructor_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"TokenBridge::exit_to_l1_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::exit_to_l1_public_parameters","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::get_portal_address_abi","fields":[{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"minters","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"total_supply","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"pending_shields","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"public_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"symbol","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}},{"name":"name","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}},{"name":"decimals","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}]}}]},{"kind":"struct","fields":[{"name":"token","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"portal_address","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}}]}],"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}]}]}},"file_map":{"22":{"source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n","path":"std/embedded_curve_ops.nr"},"23":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"24":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field/mod.nr"},"27":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\ntrait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n","path":"std/hash/mod.nr"},"32":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"50":{"source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n","path":"std/option.nr"},"56":{"source":"use crate::append::Append;\n\nimpl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n","path":"std/slice.nr"},"59":{"source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        (if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (unsafe {\n                        U128::uconstrained_check_is_upper_ascii(ascii) as u8\n                    });\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        }) as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            \n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q,r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c,d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d)= a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n","path":"std/uint128.nr"},"61":{"source":"// docs:start:token_bridge_imports\n\n// Minimal implementation of the token bridge that can move funds between L1 <> L2.\n// The bridge has a corresponding Portal contract on L1 that it is attached to\n// And corresponds to a Token on L2 that uses the `AuthWit` accounts pattern.\n// Bridge has to be set as a minter on the token before it can be used\n\ncontract TokenBridge {\n    use dep::aztec::prelude::{FunctionSelector, AztecAddress, EthAddress, PublicMutable, SharedImmutable};\n\n    use dep::token_portal_content_hash_lib::{get_mint_public_content_hash, get_mint_private_content_hash, get_withdraw_content_hash};\n\n    use dep::token::Token;\n    // docs:end:token_bridge_imports\n\n    // docs:start:token_bridge_storage_and_constructor\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[aztec(storage)]\n    struct Storage {\n        token: PublicMutable<AztecAddress>,\n        portal_address: SharedImmutable<EthAddress>,\n    }\n\n    // Constructs the contract.\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(token: AztecAddress, portal_address: EthAddress) {\n        storage.token.write(token);\n        storage.portal_address.initialize(portal_address);\n    }\n    // docs:end:token_bridge_storage_and_constructor\n\n    #[aztec(private)]\n    fn get_portal_address() -> EthAddress {\n        storage.portal_address.read_private()\n    }\n\n    #[aztec(public)]\n    fn get_portal_address_public() -> EthAddress {\n        storage.portal_address.read_public()\n    }\n\n    // docs:start:claim_public\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount publicly\n    #[aztec(public)]\n    fn claim_public(to: AztecAddress, amount: Field, secret: Field, message_leaf_index: Field) {\n        let content_hash = get_mint_public_content_hash(to, amount);\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret,\n            storage.portal_address.read_public(),\n            message_leaf_index\n        );\n\n        // Mint tokens\n        Token::at(storage.token.read()).mint_public(to, amount).call(&mut context);\n    }\n    // docs:end:claim_public\n\n    // docs:start:exit_to_l1_public\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message publicly\n    // Requires `msg.sender` to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[aztec(public)]\n    fn exit_to_l1_public(\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read_public(), content);\n\n        // Burn tokens\n        Token::at(storage.token.read()).burn_public(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    // docs:end:exit_to_l1_public\n    // docs:start:claim_private\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount in private assets\n    // User needs to call token.redeem_shield() to get the private assets\n    #[aztec(private)]\n    fn claim_private(\n        secret_hash_for_redeeming_minted_notes: Field, // secret hash used to redeem minted notes at a later time. This enables anyone to call this function and mint tokens to a user on their behalf\n        amount: Field,\n        secret_for_L1_to_L2_message_consumption: Field // secret used to consume the L1 to L2 message\n    ) {\n        // Consume L1 to L2 message and emit nullifier\n        let content_hash = get_mint_private_content_hash(secret_hash_for_redeeming_minted_notes, amount);\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret_for_L1_to_L2_message_consumption,\n            storage.portal_address.read_private()\n        );\n\n        // Mint tokens on L2\n        // `mint_private` on token is public. So we call an internal public function\n        // which then calls the public method on the token contract.\n        // Since the secret_hash is passed, no secret is leaked.\n        TokenBridge::at(context.this_address())._call_mint_on_token(amount, secret_hash_for_redeeming_minted_notes).enqueue(&mut context);\n    }\n    // docs:end:claim_private\n\n    // docs:start:exit_to_l1_private\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message privately\n    // Requires `msg.sender` (caller of the method) to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[aztec(private)]\n    fn exit_to_l1_private(\n        token: AztecAddress,\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read_private(), content);\n\n        // docs:start:call_assert_token_is_same\n        // Assert that user provided token address is same as seen in storage.\n        TokenBridge::at(context.this_address())._assert_token_is_same(token).enqueue(&mut context);\n        // docs:end:call_assert_token_is_same\n\n        // Burn tokens\n        Token::at(token).burn(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    /// docs:end:exit_to_l1_private\n\n    // docs:start:get_token\n    #[aztec(public)]\n    #[aztec(view)]\n    fn get_token() -> AztecAddress {\n        storage.token.read()\n    }\n    // docs:end:get_token\n\n    // docs:start:call_mint_on_token\n    // This is a public call as we need to read from public storage.\n    // Also, note that user hashes their secret in private and only sends the hash in public\n    // meaning only user can `redeem_shield` at a later time with their secret.\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _call_mint_on_token(amount: Field, secret_hash: Field) {\n        Token::at(storage.token.read()).mint_private(amount, secret_hash).call(&mut context);\n    }\n    // docs:end:call_mint_on_token\n\n    // docs:start:assert_token_is_same\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _assert_token_is_same(token: AztecAddress) {\n        assert(storage.token.read().eq(token), \"Token address is not the same as seen in storage\");\n    }\n    // docs:end:assert_token_is_same\n}\n","path":"/home/filip/c/aztec-token-bridge/packages/aztec-contracts/token_bridge/src/main.nr"},"62":{"source":"use crate::{\n    hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness\n};\n\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\nuse dep::protocol_types::{constants::L1_TO_L2_MSG_TREE_HEIGHT, address::{AztecAddress, EthAddress}, utils::arr_copy_slice};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_message_hash(\n        portal_contract_address,\n        chain_id,\n        storage_contract_address,\n        version,\n        content,\n        secret_hash\n    );\n\n    let returned_message = get_l1_to_l2_membership_witness(storage_contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = arr_copy_slice(returned_message, [0; L1_TO_L2_MSG_TREE_HEIGHT], 1);\n\n    // Check that the message is in the tree\n    // This is implicitly checking that the values of the message are correct\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\n    assert(root == l1_to_l2_root, \"Message not in state\");\n\n    compute_message_nullifier(message_hash, secret, leaf_index)\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/messaging.nr"},"81":{"source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32, let M: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the \n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the \n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from \n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"89":{"source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext}, oracle::storage::storage_read,\n    state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\nstruct SharedImmutable<T, Context>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, T_SERIALIZED_LEN> SharedImmutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // Intended to be only called once. \n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n\n    pub fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, T_SERIALIZED_LEN> SharedImmutable<T, UnconstrainedContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, T_SERIALIZED_LEN> SharedImmutable<T, &mut PrivateContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    pub fn read_private(self) -> T {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] =\n                header.public_storage_historical_read(\n                    self.storage_slot + i as Field,\n                    (*self.context).this_address()\n                );\n        }\n        T::deserialize(fields)\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr"},"105":{"source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"108":{"source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr"},"109":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, gas::Gas,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, public_call_stack_item::PublicCallStackItem,\n    public_call_stack_item_compressed::PublicCallStackItemCompressed, read_request::ReadRequest,\n    note_hash::NoteHash, nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        let call_request = PublicCallRequest { item, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            item,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"110":{"source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<let N: u32, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"118":{"source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<let N: u32>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N as Field)\n}\n\nunconstrained fn storage_write<let N: u32>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<let N: u32>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<let N: u32>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"120":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash,\n    hash::{\n    pedersen_hash, compute_siloed_nullifier, sha256_to_field, pedersen_commitment,\n    poseidon2_hash_with_separator\n}\n};\n// Note: pedersen_commitment is used only as a re-export here\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        poseidon2_hash_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x1cce4dbf69f14c44865919991ee1057922e34d7310ba237d71759aa422621ca9);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/hash.nr"},"131":{"source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::{PrivateContext, UnconstrainedContext},\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{\n    public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH}, stored_keys::StoredKeys,\n    constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}\n},\n    state_vars::{\n    shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter,\n    public_mutable::PublicMutable, map::Map\n}\n};\n\nmod test;\n\n// This is the number of blocks that must pass after a key rotation event until the old keys are fully phased out and\n// become invalid.\nglobal KEY_REGISTRY_UPDATE_BLOCKS = 5;\n\nglobal KEY_REGISTRY_STORAGE_SLOT = 1;\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// Returns all current public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_current_public_keys(context: &mut PrivateContext, account: AztecAddress) -> PublicKeys {\n    // We're going to perform historical reads from public storage, and so need to constrain the caller so that they\n    // cannot use very old blocks when constructing proofs, and hence e.g. read very old keys. We are lax and allow\n    // _any_ recent block number to be used, regardless of whether there may have been a recent key rotation. This means\n    // that multiple sets of keys are valid for a while immediately after rotation, until the old keys become phased\n    // out. We *must* be lax to prevent denial of service and transaction fingerprinting attacks by accounts that rotate\n    // their keys frequently.\n    // Note that we constrain the max block number even if the registry ends up being empty: this ensures that proof of\n    // an empty registry is also fresh.\n    let current_header = context.get_header();\n    context.set_tx_max_block_number(current_header.global_variables.block_number as u32 + KEY_REGISTRY_UPDATE_BLOCKS);\n\n    get_historical_public_keys(current_header, account)\n}\n\n// Returns historical public keys for a given account at some block determined by a block header. We read all keys at\n// once since the constraints for reading them all are actually fewer than if we read them one at a time - any read keys\n// that are not required by the caller can simply be discarded.\n// WARNING: if called with a historical header created from a fixed block this function will explicitly ignore key\n// rotation! This means that callers of this may force a user to use old keys, potentially leaking privacy (e.g. if the\n// old keys were leaked). Only call this function with a header from a fixed block if you understand the implications of\n// breaking key rotation very well.\npub fn get_historical_public_keys(historical_header: Header, account: AztecAddress) -> PublicKeys {\n    // TODO: improve this so that we always hint the correct set of keys (either registry or canonical) and hash them\n    // once instead of having two different hints and twice as many constraints due to the double hashing.\n\n    // The key registry is the primary source of information for keys, as that's where accounts store their new keys\n    // when they perform rotation. The key registry conveniently stores a hash of each user's keys, so we can read that\n    // single field and then prove that we know its preimage (i.e. the current set of keys).\n    let key_registry_hash = key_registry_hash_public_historical_read(historical_header, account);\n    if key_registry_hash != 0 {\n        let hinted_registry_public_keys = key_registry_get_stored_keys_hint(\n            account,\n            historical_header.global_variables.block_number as u32\n        );\n        assert_eq(hinted_registry_public_keys.hash().to_field(), key_registry_hash);\n\n        hinted_registry_public_keys\n    } else {\n        // If nothing was written to the registry, we may still be able to produce the correct keys if we happen to know\n        // the canonical set (i.e. the ones that are part of the account's preimage).\n        let (hinted_canonical_public_keys, partial_address) = get_public_keys_and_partial_address(account);\n        assert_eq(\n            account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n        );\n\n        hinted_canonical_public_keys\n    }\n}\n\nfn key_registry_hash_public_historical_read(historical_header: Header, account: AztecAddress) -> Field {\n    // The keys are stored in a Map that is keyed with the address of each account, so we first derive the corresponding\n    // slot for this account.\n    let keys_storage_slot = derive_storage_slot_in_map(KEY_REGISTRY_STORAGE_SLOT, account);\n\n    // The keys are stored as [ ...serialized_keys, hash ], and since arrays get allocated sequential storage slots\n    // (prior to siloing!), we simply add the length to the base slot to get the last element.\n    let hash_storage_slot = keys_storage_slot + PUBLIC_KEYS_LENGTH as Field;\n\n    historical_header.public_storage_historical_read(hash_storage_slot, CANONICAL_KEY_REGISTRY_ADDRESS)\n}\n\nunconstrained fn key_registry_get_stored_keys_hint(account: AztecAddress, block_number: u32) -> PublicKeys {\n    // This is equivalent to the key registry contract having an unconstrained getter that we call from an oracle, but\n    // PXE does not yet support that functionality so we do this manually instad. Note that this would be a *historical*\n    // call!\n\n    // TODO (#7524): call the unconstrained KeyRegistry.get_current_keys() function instead\n\n    let context = UnconstrainedContext::at_historical(CANONICAL_KEY_REGISTRY_ADDRESS, block_number);\n    let keys_storage = Map::new(\n        context,\n        KEY_REGISTRY_STORAGE_SLOT,\n        |context, slot| { PublicMutable::new(context, slot) }\n    );\n\n    let stored_keys: StoredKeys = keys_storage.at(account).read();\n    stored_keys.public_keys\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"138":{"source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<let N: u32>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr"},"139":{"source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"140":{"source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; 2] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr"},"143":{"source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage,\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, public_data_tree_index: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr"},"144":{"source":"#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle<let N: u32>(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/returns.nr"},"145":{"source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"149":{"source":"use dep::protocol_types::{abis::{function_selector::FunctionSelector}, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n\nunconstrained pub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"153":{"source":"use dep::protocol_types::{address::AztecAddress};\n\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: u64 = 17;\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {}\n\nunconstrained pub fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {\n    get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret)\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr"},"162":{"source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    address::AztecAddress, header::Header, utils::field::full_field_less_than\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_data_tree_index\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_data_tree_index, \"Public data tree index doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == root_from_sibling_path(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/history/public_storage.nr"},"167":{"source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/initializer.nr"},"171":{"source":"use crate::{constants::ETH_ADDRESS_LENGTH, traits::{Empty, ToField, Serialize, Deserialize}, utils};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr"},"173":{"source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash_with_separator,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"177":{"source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"190":{"source":"struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"192":{"source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes = max_value.to_be_bytes(32);\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"193":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr"},"211":{"source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"212":{"source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"213":{"source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc, point::Point\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"221":{"source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr"},"226":{"source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like \n// this because it means we never even need to consider cases where \n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N]\n) -> Field {\n    let mut node = leaf;\n    let indices = leaf_index.to_le_bits(N);\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        assert(false, \"depth should be between 0 and 10\");\n        0\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr"},"243":{"source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"292":{"source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x:fields[0], y: fields[1], is_infinite: fields[2] as bool},\n            sk_app: fields[3],\n        }\n    }\n}\n\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"311":{"source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n\ncontract Token {\n    // Libs\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        context::{PrivateContext, PrivateCallInterface}, hash::compute_secret_hash,\n        prelude::{\n        NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress,\n        FunctionSelector, NoteHeader, Point\n    },\n        encrypted_logs::{\n        encrypted_note_emission::{encode_and_encrypt_note_with_keys, encode_and_encrypt_note_with_keys_unconstrained},\n        encrypted_event_emission::{encode_and_encrypt_event, encode_and_encrypt_event_with_keys_unconstrained}\n    },\n        keys::getters::get_current_public_keys\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{assert_current_call_valid_authwit, assert_current_call_valid_authwit_public, compute_authwit_nullifier};\n    // docs:end:import_authwit\n\n    use crate::types::{\n        transparent_note::TransparentNote,\n        token_note::{TokenNote, TOKEN_NOTE_LEN, TokenNoteHidingPoint}, balances_map::BalancesMap\n    };\n    // docs:end::imports\n\n    // In the first transfer iteration we are computing a lot of additional information (validating inputs, retrieving\n    // keys, etc.), so the gate count is already relatively high. We therefore only read a few notes to keep the happy\n    // case with few constraints.\n    global INITIAL_TRANSFER_CALL_MAX_NOTES = 2;\n    // All the recursive call does is nullify notes, meaning the gate count is low, but it is all constant overhead. We\n    // therefore read more notes than in the base case to increase the efficiency of the overhead, since this results in\n    // an overall small circuit regardless.\n    global RECURSIVE_TRANSFER_CALL_MAX_NOTES = 8;\n\n    #[aztec(event)]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[aztec(storage)]\n    struct Storage {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool>>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: BalancesMap<TokenNote>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128>>,\n        symbol: SharedImmutable<FieldCompressedString>,\n        name: SharedImmutable<FieldCompressedString>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[aztec(public)]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n\n    // docs:start:admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[aztec(public)]\n    #[aztec(view)]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[aztec(public)]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_public\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n\n    // docs:start:mint_private\n    #[aztec(public)]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[aztec(private)]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        let caller_keys = get_current_public_keys(&mut context, caller);\n        storage.balances.add(caller, caller_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note_with_keys(&mut context, caller_keys.ovpk_m, caller_keys.ivpk_m, caller)\n        );\n\n        Token::at(context.this_address()).assert_minter_and_mint(context.msg_sender(), amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n\n    // docs:start:shield\n    #[aztec(public)]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n\n    // docs:start:transfer_public\n    #[aztec(public)]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n\n    // docs:start:burn_public\n    #[aztec(public)]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:redeem_shield\n    #[aztec(private)]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let secret_hash = compute_secret_hash(secret);\n\n        // Pop 1 note (set_limit(1)) which has an amount stored in a field with index 0 (select(0, amount)) and\n        // a secret_hash stored in a field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options.select(TransparentNote::properties().amount, amount, Option::none()).select(\n            TransparentNote::properties().secret_hash,\n            secret_hash,\n            Option::none()\n        ).set_limit(1);\n\n        let notes = storage.pending_shields.pop_notes(options);\n        assert(notes.len() == 1, \"note not popped\");\n\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        let from_keys = get_current_public_keys(&mut context, from);\n        let to_keys = get_current_public_keys(&mut context, to);\n        storage.balances.add(to, to_keys.npk_m, U128::from_integer(amount)).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to));\n    }\n    // docs:end:redeem_shield\n\n    // docs:start:unshield\n    #[aztec(private)]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        storage.balances.sub(from, from_keys.npk_m, U128::from_integer(amount)).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from));\n\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n\n    // docs:start:transfer\n    #[aztec(private)]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        let to_keys = get_current_public_keys(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n\n        // We reduce `from`'s balance by amount by recursively removing notes over potentially multiple calls. This\n        // method keeps the gate count for each individual call low - reading too many notes at once could result in\n        // circuits in which proving is not feasible.\n        // Since the sum of the amounts in the notes we nullified was potentially larger than amount, we create a new\n        // note for `from` with the change amount, e.g. if `amount` is 10 and two notes are nullified with amounts 8 and\n        // 5, then the change will be 3 (since 8 + 5 - 10 = 3).\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            from,\n            amount,\n            INITIAL_TRANSFER_CALL_MAX_NOTES\n        );\n\n        storage.balances.add(from, from_keys.npk_m, change).emit(\n            encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from)\n        );\n\n        storage.balances.add(to, to_keys.npk_m, amount).emit(\n            encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to)\n        );\n\n        // We don't constrain encryption of the note log in `transfer` (unlike in `transfer_from`) because the transfer\n        // function is only designed to be used in situations where the event is not strictly necessary (e.g. payment to\n        // another person where the payment is considered to be successful when the other party successfully decrypts a\n        // note).\n        Transfer { from, to, amount: amount.to_field() }.emit(\n            encode_and_encrypt_event_with_keys_unconstrained(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to)\n        );\n    }\n    // docs:end:transfer\n\n    #[contract_library_method]\n    fn subtract_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        account: AztecAddress,\n        amount: U128,\n        max_notes: u32\n    ) -> U128 {\n        let subtracted = storage.balances.try_sub(account, amount, max_notes);\n\n        // Failing to subtract any amount means that the owner was unable to produce more notes that could be nullified.\n        // We could in some cases fail early inside try_sub if we detected that fewer notes than the maximum were\n        // returned and we were still unable to reach the target amount, but that'd make the code more complicated, and\n        // optimizing for the failure scenario is not as important.\n        assert(subtracted > U128::from_integer(0), \"Balance too low\");\n\n        if subtracted >= amount {\n            // We have achieved our goal of nullifying notes that add up to more than amount, so we return the change\n            subtracted - amount\n        } else {\n            // try_sub failed to nullify enough notes to reach the target amount, so we compute the amount remaining\n            // and try again.\n            let remaining = amount - subtracted;\n            compute_recurse_subtract_balance_call(*context, account, remaining).call(context)\n        }\n    }\n\n    // TODO(#7729): apply no_predicates to the contract interface method directly instead of having to use a wrapper\n    // like we do here.\n    #[no_predicates]\n    #[contract_library_method]\n    fn compute_recurse_subtract_balance_call(\n        context: PrivateContext,\n        account: AztecAddress,\n        remaining: U128\n    ) -> PrivateCallInterface<25, U128, (AztecAddress, Field)> {\n        Token::at(context.this_address())._recurse_subtract_balance(account, remaining.to_field())\n    }\n\n    // TODO(#7728): even though the amount should be a U128, we can't have that type in a contract interface due to\n    // serialization issues.\n    #[aztec(internal)]\n    #[aztec(private)]\n    fn _recurse_subtract_balance(account: AztecAddress, amount: Field) -> U128 {\n        subtract_balance(\n            &mut context,\n            storage,\n            account,\n            U128::from_integer(amount),\n            RECURSIVE_TRANSFER_CALL_MAX_NOTES\n        )\n    }\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[aztec(private)]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_from\n    #[aztec(private)]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        let to_keys = get_current_public_keys(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.sub(from, from_keys.npk_m, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.add(to, to_keys.npk_m, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to));\n    }\n    // docs:end:transfer_from\n\n    // docs:start:burn\n    #[aztec(private)]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        storage.balances.sub(from, from_keys.npk_m, U128::from_integer(amount)).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from));\n\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n\n    /// We need to use different randomness for the user and for the fee payer notes because if the randomness values\n    /// were the same we could fingerprint the user by doing the following:\n    ///      1) randomness_influence = fee_payer_point - G_npk * fee_payer_npk =\n    ///                              = (G_npk * fee_payer_npk + G_rnd * randomness) - G_npk * fee_payer_npk =\n    ///                              = G_rnd * randomness\n    ///      2) user_fingerprint = user_point - randomness_influence =\n    ///                          = (G_npk * user_npk + G_rnd * randomness) - G_rnd * randomness =\n    ///                          = G_npk * user_npk\n    ///      3) Then the second time the user would use this fee paying contract we would recover the same fingerprint\n    ///         and link that the 2 transactions were made by the same user. Given that it's expected that only\n    ///         a limited set of fee paying contracts will be used and they will be known, searching for fingerprints\n    ///         by trying different fee payer npk values of these known contracts is a feasible attack.\n    ///\n    /// `fee_payer_point` and `user_point` above are public information because they are passed as args to the public\n    /// `complete_refund(...)` function.\n    #[aztec(private)]\n    fn setup_refund(\n        fee_payer: AztecAddress, // Address of the entity which will receive the fee note.\n        user: AztecAddress, // A user for which we are setting up the fee refund.\n        funded_amount: Field, // The amount the user funded the fee payer with (represents fee limit).\n        user_randomness: Field, // A randomness to mix in with the generated refund note for the sponsored user.\n        fee_payer_randomness: Field // A randomness to mix in with the generated fee note for the fee payer.\n    ) {\n        // 1. This function is called by fee paying contract (fee_payer) when setting up a refund so we need to support\n        // the authwit flow here and check that the user really permitted fee_payer to set up a refund on their behalf.\n        assert_current_call_valid_authwit(&mut context, user);\n\n        // 2. Get all the relevant keys\n        let fee_payer_npk_m_hash = get_current_public_keys(&mut context, fee_payer).npk_m.hash();\n        let user_keys = get_current_public_keys(&mut context, user);\n        let user_npk_m_hash = user_keys.npk_m.hash();\n\n        // 3. Deduct the funded amount from the user's balance - this is a maximum fee a user is willing to pay\n        // (called fee limit in aztec spec). The difference between fee limit and the actual tx fee will be refunded \n        // to the user in the `complete_refund(...)` function.\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            user,\n            U128::from_integer(funded_amount),\n            INITIAL_TRANSFER_CALL_MAX_NOTES\n        );\n        storage.balances.add(user, user_keys.npk_m, change).emit(\n            encode_and_encrypt_note_with_keys_unconstrained(&mut context, user_keys.ovpk_m, user_keys.ivpk_m, user)\n        );\n\n        // 4. We create the partial notes for the fee payer and the user.\n        // --> Called \"partial\" because they don't have the amount set yet (that will be done in `complete_refund(...)`).\n        let fee_payer_partial_note = TokenNote {\n            header: NoteHeader {\n                contract_address: AztecAddress::zero(),\n                nonce: 0,\n                storage_slot: storage.balances.map.at(fee_payer).storage_slot,\n                note_hash_counter: 0\n            },\n            amount: U128::zero(),\n            npk_m_hash: fee_payer_npk_m_hash,\n            randomness: fee_payer_randomness\n        };\n        let user_partial_note = TokenNote {\n            header: NoteHeader {\n                contract_address: AztecAddress::zero(),\n                nonce: 0,\n                storage_slot: storage.balances.map.at(user).storage_slot,\n                note_hash_counter: 0\n            },\n            amount: U128::zero(),\n            npk_m_hash: user_npk_m_hash,\n            randomness: user_randomness\n        };\n\n        // 5. Now we get the note hiding points.\n        let mut fee_payer_point = fee_payer_partial_note.to_note_hiding_point();\n        let mut user_point = user_partial_note.to_note_hiding_point();\n\n        // 6. Set the public teardown function to `complete_refund(...)`. Public teardown is the only time when a public\n        // function has access to the final transaction fee, which is needed to compute the actual refund amount.\n        context.set_public_teardown_function(\n            context.this_address(),\n            FunctionSelector::from_signature(\"complete_refund(((Field,Field,bool)),((Field,Field,bool)),Field)\"),\n            [\n            fee_payer_point.inner.x, fee_payer_point.inner.y, fee_payer_point.inner.is_infinite as Field, user_point.inner.x, user_point.inner.y, user_point.inner.is_infinite as Field, funded_amount\n        ]\n        );\n    }\n\n    // TODO(#7728): even though the funded_amount should be a U128, we can't have that type in a contract interface due\n    // to serialization issues.\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn complete_refund(\n        // TODO(#7771): the following makes macros crash --> try getting it work once we migrate to metaprogramming\n        // mut fee_payer_point: TokenNoteHidingPoint,\n        // mut user_point: TokenNoteHidingPoint,\n        fee_payer_point_immutable: TokenNoteHidingPoint,\n        user_point_immutable: TokenNoteHidingPoint,\n        funded_amount: Field\n    ) {\n        // TODO(#7771): nuke the following 2 lines once we have mutable args\n        let mut fee_payer_point = fee_payer_point_immutable;\n        let mut user_point = user_point_immutable;\n\n        // TODO(#7728): Remove the next line\n        let funded_amount = U128::from_integer(funded_amount);\n        let tx_fee = U128::from_integer(context.transaction_fee());\n\n        // 1. We check that user funded the fee payer contract with at least the transaction fee.\n        // TODO(#7796): we should try to prevent reverts here\n        assert(funded_amount >= tx_fee, \"funded amount not enough to cover tx fee\");\n\n        // 2. We compute the refund amount as the difference between funded amount and tx fee.\n        let refund_amount = funded_amount - tx_fee;\n\n        // 3. We add fee to the fee payer point and refund amount to the user point.\n        fee_payer_point.add_amount(tx_fee);\n        user_point.add_amount(refund_amount);\n\n        // 4. We finalize the hiding points to get the note hashes.\n        let fee_payer_note_hash = fee_payer_point.finalize();\n        let user_note_hash = user_point.finalize();\n\n        // 5. At last we emit the note hashes.\n        context.push_note_hash(fee_payer_note_hash);\n        context.push_note_hash(user_note_hash);\n        // --> Once the tx is settled user and fee recipient can add the notes to their pixies.\n    }\n\n    /// Internal ///\n\n    // docs:start:increase_public_balance\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n\n    // docs:start:balance_of_private\n    unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.balance_of(owner).to_field()\n    }\n    // docs:end:balance_of_private\n}\n\n// docs:end:token_all\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-contracts/contracts/token_contract/src/main.nr"},"313":{"source":"use dep::aztec::{\n    generators::{Ga1 as G_amt, Ga2 as G_npk, Ga3 as G_rnd, G_slot},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{\n    constants::GENERATOR_INDEX__NOTE_NULLIFIER, point::{Point, POINT_LENGTH}, scalar::Scalar,\n    hash::poseidon2_hash_with_separator, traits::Serialize\n},\n    note::utils::compute_note_hash_for_nullify, oracle::unsafe_rand::unsafe_rand,\n    keys::getters::get_nsk_app\n};\nuse dep::std::{embedded_curve_ops::multi_scalar_mul, hash::from_field_unsafe};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\nglobal TOKEN_NOTE_LEN: Field = 3; // 3 plus a header.\nglobal TOKEN_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n#[aztec(note)]\nstruct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n\nimpl NoteInterface<TOKEN_NOTE_LEN, TOKEN_NOTE_BYTES_LEN> for TokenNote {\n    // docs:start:nullifier\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([note_hash_for_nullify, secret],GENERATOR_INDEX__NOTE_NULLIFIER)\n    }\n\n    fn compute_note_hiding_point(self) -> Point {\n        // We use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        let amount_scalar = from_field_unsafe(self.amount.to_integer());\n        let npk_m_hash_scalar = from_field_unsafe(self.npk_m_hash);\n        let randomness_scalar = from_field_unsafe(self.randomness);\n        let slot_scalar = from_field_unsafe(self.header.storage_slot);\n        // We compute the note hiding point as:\n        //     `G_amt * amount + G_npk * npk_m_hash + G_rnd * randomness + G_slot * slot`\n        // instead of using pedersen or poseidon2 because it allows us to privately add and subtract from amount\n        // in public by leveraging homomorphism.\n        multi_scalar_mul(\n            [G_amt, G_npk, G_rnd, G_slot],\n            [amount_scalar, npk_m_hash_scalar, randomness_scalar, slot_scalar]\n        )\n    }\n}\n\nimpl TokenNote {\n    // TODO: Merge this func with `compute_note_hiding_point`. I (benesjan) didn't do it in the initial PR to not have\n    // to modify macros and all the related funcs in it.\n    fn to_note_hiding_point(self) -> TokenNoteHidingPoint {\n        TokenNoteHidingPoint::new(self.compute_note_hiding_point())\n    }\n}\n\nstruct TokenNoteHidingPoint {\n  inner: Point\n}\n\nimpl TokenNoteHidingPoint {\n    fn new(point: Point) -> Self {\n        Self { inner: point }\n    }\n\n    fn add_amount(&mut self, amount: U128) {\n        self.inner = multi_scalar_mul([G_amt], [from_field_unsafe(amount.to_integer())]) + self.inner;\n    }\n\n    fn add_npk_m_hash(&mut self, npk_m_hash: Field) {\n        self.inner = multi_scalar_mul([G_npk], [from_field_unsafe(npk_m_hash)]) + self.inner;\n    }\n\n    fn add_randomness(&mut self, randomness: Field) {\n        self.inner = multi_scalar_mul([G_rnd], [from_field_unsafe(randomness)]) + self.inner;\n    }\n\n    fn add_slot(&mut self, slot: Field) {\n        self.inner = multi_scalar_mul([G_slot], [from_field_unsafe(slot)]) + self.inner;\n    }\n\n    fn finalize(self) -> Field {\n        self.inner.x\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TokenNoteHidingPoint {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Eq for TokenNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        Self {\n            amount,\n            npk_m_hash: owner_npk_m_hash,\n            randomness: unsafe_rand(),\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-contracts/contracts/token_contract/src/types/token_note.nr"},"315":{"source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::{note_getter_options::PropertySelector, utils::compute_note_hash_for_nullify},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator}\n};\n\nglobal TRANSPARENT_NOTE_LEN: Field = 2;\n// TRANSPARENT_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TRANSPARENT_NOTE_BYTES_LEN: Field = 2 * 32 + 64;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[aztec(note)]\nstruct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nstruct TransparentNoteProperties {\n    amount: PropertySelector,\n    secret_hash: PropertySelector,\n}\n\nimpl NoteInterface<TRANSPARENT_NOTE_LEN, TRANSPARENT_NOTE_BYTES_LEN> for TransparentNote {\n\n    // Custom serialization to avoid disclosing the secret field\n    fn serialize_content(self) -> [Field; TRANSPARENT_NOTE_LEN] {\n        [self.amount, self.secret_hash]\n    }\n\n    // Custom deserialization since we don't have access to the secret plaintext\n    fn deserialize_content(serialized_note: [Field; TRANSPARENT_NOTE_LEN]) -> Self {\n        TransparentNote {\n            amount: serialized_note[0],\n            secret_hash: serialized_note[1],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_nullifier(self, _context: &mut PrivateContext, _note_hash_for_nullify: Field) -> Field {\n        self.compute_nullifier_without_context()\n    }\n\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit. \n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n\n    // CUSTOM FUNCTIONS FOR THIS NOTE TYPE\n    // Custom serialization forces us to manually create the metadata struct and its getter\n    pub fn properties() -> TransparentNoteProperties {\n        TransparentNoteProperties {\n            amount: PropertySelector { index: 0, offset: 0, length: 32 },\n            secret_hash: PropertySelector { index: 1, offset: 0, length: 32 }\n        }\n    }\n}\n\nimpl Eq for TransparentNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) & (self.secret_hash == other.secret_hash)\n    }\n}\n\n// docs:end:token_types_all","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-contracts/contracts/token_contract/src/types/transparent_note.nr"},"328":{"source":"// docs:start:mint_public_content_hash_nr\nuse dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\n// Computes a content hash of a deposit/mint_public message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_public_content_hash(owner: AztecAddress, amount: Field) -> Field {\n    let mut hash_bytes = [0; 68];\n    let recipient_bytes = owner.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0x3e87b9be keccak256('mint_public(bytes32,uint256)')\n    hash_bytes[0] = 0x3e;\n    hash_bytes[1] = 0x87;\n    hash_bytes[2] = 0xb9;\n    hash_bytes[3] = 0xbe;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:mint_public_content_hash_nr\n\n// docs:start:get_mint_private_content_hash\n// Computes a content hash of a deposit/mint_private message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_private_content_hash(\n    secret_hash_for_redeeming_minted_notes: Field,\n    amount: Field\n) -> Field {\n    let mut hash_bytes = [0; 68];\n    let secret_hash_bytes = secret_hash_for_redeeming_minted_notes.to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = secret_hash_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0xefa012c1 keccak256('mint_private(bytes32,uint256)')\n    hash_bytes[0] = 0xef;\n    hash_bytes[1] = 0xa0;\n    hash_bytes[2] = 0x12;\n    hash_bytes[3] = 0xc1;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_mint_private_content_hash\n\n// docs:start:get_withdraw_content_hash\n// Computes a content hash of a withdraw message.\npub fn get_withdraw_content_hash(recipient: EthAddress, amount: Field, caller_on_l1: EthAddress) -> Field {\n    // Compute the content hash\n    // Compute sha256(selector || amount || recipient)\n    // then convert to a single field element\n    // add that to the l2 to l1 messages\n    let mut hash_bytes: [u8; 100] = [0; 100];\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n    let caller_on_l1_bytes = caller_on_l1.to_field().to_be_bytes(32);\n\n    //  0x69328dec, selector for \"withdraw(address,uint256,address)\"\n    hash_bytes[0] = 0x69;\n    hash_bytes[1] = 0x32;\n    hash_bytes[2] = 0x8d;\n    hash_bytes[3] = 0xec;\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n        hash_bytes[i + 68] = caller_on_l1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_withdraw_content_hash\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-contracts/contracts/token_portal_content_hash_lib/src/lib.nr"}}}